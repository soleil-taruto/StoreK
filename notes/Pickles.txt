----
Make10

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		MakeTen(1, 1, 5, 8);
		MakeTen(4, 4, 6, 6);
		MakeTen(3, 4, 7, 8);
		MakeTen(5, 6, 7, 8);
	}

	private class Operand
	{
		public int Numer;
		public int Denom;
		public string Str;

		public bool IsInt()
		{
			return this.Numer % this.Denom == 0;
		}

		public int GetIntValue()
		{
			return this.Numer / this.Denom;
		}
	}

	private static void MakeTen(params int[] ns)
	{
		Console.WriteLine(string.Join(", ", ns) + " ==>");
		OpStrs = new List<string>();
		MakeTen(ns.Select(v => new Operand() { Numer = v, Denom = 1, Str = "" + v }).ToArray());

		foreach (string str in OpStrs.Distinct())
			Console.WriteLine("\t" + str + " = 10");

		OpStrs = null;
		Console.WriteLine("");
	}

	private static List<string> OpStrs;

	private static void MakeTen(Operand[] os)
	{
		if (os.Length == 1)
		{
			Operand o = os[0];

			if (
				o.IsInt() &&
				o.GetIntValue() == 10
				)
				OpStrs.Add(o.Str);

			return;
		}

		for (int a = 0; a < os.Length; a++)
		for (int b = 0; b < os.Length; b++)
		{
			if (a == b)
				continue;

			Operand[] next = os.ToArray();
			next[a] = null;
			next[b] = null;
			next = next.Where(v => v != null).Concat(new Operand[] { null }).ToArray();
			int x = next.Length - 1;

			next[x] = new Operand()
			{
				Numer = os[a].Numer * os[b].Denom + os[b].Numer * os[a].Denom,
				Denom = os[a].Denom * os[b].Denom,
				Str = "(" + os[a].Str + " + " + os[b].Str + ")",
			};

			MakeTen(next);

			next[x] = new Operand()
			{
				Numer = os[a].Numer * os[b].Denom - os[b].Numer * os[a].Denom,
				Denom = os[a].Denom * os[b].Denom,
				Str = "(" + os[a].Str + " - " + os[b].Str + ")",
			};

			MakeTen(next);

			next[x] = new Operand()
			{
				Numer = os[a].Numer * os[b].Numer,
				Denom = os[a].Denom * os[b].Denom,
				Str = "(" + os[a].Str + " * " + os[b].Str + ")",
			};

			MakeTen(next);

			if (os[b].Numer != 0)
			{
				next[x] = new Operand()
				{
					Numer = os[a].Numer * os[b].Denom,
					Denom = os[a].Denom * os[b].Numer,
					Str = "(" + os[a].Str + " / " + os[b].Str + ")",
				};

				MakeTen(next);
			}
		}
	}
}

----
MergeSort

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			var arr = GetRandIntList(60)
				.ToArray().Skip(0); // ÉäÉXÉgÇämíËÇ∑ÇÈÅB

			Console.WriteLine("Before: " + string.Join(", ", arr));

			arr = MergeSort(arr, (a, b) => a - b);

			Console.WriteLine("After : " + string.Join(", ", arr));
		}
	}

	private static IEnumerable<T> MergeSort<T>(IEnumerable<T> list, Comparison<T> comp)
	{
		Queue<IEnumerable<T>> q = new Queue<IEnumerable<T>>(list.Select(v => new T[] { v }));

		if (q.Count == 0)
			return new T[0];

		while (2 <= q.Count)
			q.Enqueue(E_Merge(q.Dequeue(), q.Dequeue(), comp));

		return q.Dequeue();
	}

	private static IEnumerable<T> E_Merge<T>(IEnumerable<T> v1, IEnumerable<T> v2, Comparison<T> comp)
	{
		IEnumerator<T> a = v1.GetEnumerator();
		IEnumerator<T> b = v2.GetEnumerator();

		if (!a.MoveNext()) throw null;
		if (!b.MoveNext()) throw null;

		for (; ; )
		{
			int ret = comp(a.Current, b.Current);

			if (ret <= 0)
			{
				yield return a.Current;
				if (!a.MoveNext()) { a = b; break; }
			}
			if (0 <= ret)
			{
				yield return b.Current;
				if (!b.MoveNext()) break;
			}
		}
		do { yield return a.Current; } while (a.MoveNext());
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList(int scale)
	{
		int count = GetRandInt(scale);
		int limit = GetRandInt(scale) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----
MergeSort ämîFóp

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 30; testcnt++)
		{
			int[] arr1 = GetRandIntList(10000).ToArray();
			int[] arr2 = arr1.ToArray(); // Cloning

			Array.Sort(arr1, (a, b) => a - b);

			arr2 = MergeSort(arr2, (a, b) => a - b).ToArray();

			for (int index = 0; index < arr1.Length; index++)
				if (arr1[index] != arr2[index])
					throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static IEnumerable<T> MergeSort<T>(IEnumerable<T> list, Comparison<T> comp)
	{
		Queue<IEnumerable<T>> q = new Queue<IEnumerable<T>>(list.Select(v => new T[] { v }));

		if (q.Count == 0)
			return new T[0];

		while (2 <= q.Count)
			q.Enqueue(E_Merge(q.Dequeue(), q.Dequeue(), comp));

		return q.Dequeue();
	}

	private static IEnumerable<T> E_Merge<T>(IEnumerable<T> v1, IEnumerable<T> v2, Comparison<T> comp)
	{
		IEnumerator<T> a = v1.GetEnumerator();
		IEnumerator<T> b = v2.GetEnumerator();

		if (!a.MoveNext()) throw null;
		if (!b.MoveNext()) throw null;

		for (; ; )
		{
			int ret = comp(a.Current, b.Current);

			if (ret <= 0)
			{
				yield return a.Current;
				if (!a.MoveNext()) { a = b; break; }
			}
			if (0 <= ret)
			{
				yield return b.Current;
				if (!b.MoveNext()) break;
			}
		}
		do { yield return a.Current; } while (a.MoveNext());
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList(int scale)
	{
		int count = GetRandInt(scale);
		int limit = GetRandInt(scale) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----
Brainfuck Interpreter

#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint; // 32-bit uint

#define errorCase(status) \
	{ if ((status)) { printf("ERROR %d\n", __LINE__); exit(1); }}

#define MEMORY_SIZE 1000000

static uint Memory[MEMORY_SIZE];
static uint Ptr;

static uint Increment_Ptr(void)
{
	Ptr++;
	errorCase(Ptr == MEMORY_SIZE);
	return 0;
}
static uint Decrement_Ptr(void)
{
	errorCase(!Ptr);
	Ptr--;
	return 0;
}
static uint Increment(void)
{
	errorCase(Memory[Ptr] == ~(uint)0);
	Memory[Ptr]++;
	return 0;
}
static uint Decrement(void)
{
	errorCase(!Memory[Ptr]);
	Memory[Ptr]--;
	return 0;
}
static uint PrintChar(void)
{
	uint chr = Memory[Ptr];

	if (chr == 0x09) // ? Tab
	{
		printf("\t");
	}
	else if (chr == 0x0d) // ? CR
	{
	    // ignore CR
	}
	else if (chr == 0x0a) // ? LF
	{
		printf("\n");
	}
	else if (0x20 <= chr && chr <= 0x7e) // ? ASCII
	{
		printf("%c", (int)chr);
	}
	else
	{
		printf("[%02x]\n", chr);
	}
	return 0;
}
static uint InputChar(void)
{
	int chr = fgetc(stdin);

	if (0x00 <= chr && chr <= 0xff)
	{
		Memory[Ptr] = (uint)chr;
	}
	else
	{
		printf("INPUT ERROR\n");
	}
	return 0;
}
static uint EnterLoop(void)
{
	return Memory[Ptr] ? 1 : 0;
}
static uint End(void)
{
	exit(0);
	return 0; // dummy
}

typedef struct Command_st
{
	uint (*Method)(void);
	struct Command_st *Next[2];
	struct Command_st *StackNext;
}
Command_t;

static Command_t *MakeCommand(Command_t *p, uint (*method)(void))
{
	Command_t *i = malloc(sizeof(Command_t));

	errorCase(!i);

	i->Method = method;
	i->Next[0] = NULL;
	i->Next[1] = NULL;

	p->Next[0] = i;

	return i;
}
static Command_t *LoadProgram(char *source)
{
	Command_t *stack = NULL;
	Command_t *command;
	Command_t entry;

	command = &entry;

	for (char *p = source; *p; p++)
	{
		switch(*p)
		{
		case '>': command = MakeCommand(command, Increment_Ptr); break;
		case '<': command = MakeCommand(command, Decrement_Ptr); break;
		case '+': command = MakeCommand(command, Increment); break;
		case '-': command = MakeCommand(command, Decrement); break;
		case '.': command = MakeCommand(command, PrintChar); break;
		case ',': command = MakeCommand(command, InputChar); break;
		case '[':
			command = MakeCommand(command, EnterLoop);
			command->StackNext = stack;
			stack = command;
			break;

		case ']':
		    errorCase(!stack);
			command->Next[0] = stack;
			stack = stack->StackNext;
			command = command->Next[0];
			command->Next[1] = command->Next[0];
			break;

		default:
			break;
		}
	}
	MakeCommand(command, End);
	return entry.Next[0];
}
static void ExecuteProgram(char *source)
{
	Command_t *i = LoadProgram(source); // HACK: free

	//memset(Memory, 0x00, sizeof(Memory));
	//Ptr = 0;

	for (; ; )
	{
		i = i->Next[i->Method()];
	}
}

// ====
// ====
// ====

int main(int argc, char **argv)
{
	ExecuteProgram("++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.");
}

----

#include <stdio.h>
#include <time.h>

#define SEC_DIV 2

static long TryGetIncrementPerSec(void)
{
	static long checkPeriod = 1;
	long c;
	long stClock = clock();

	for (c = 0; c % checkPeriod || clock() - stClock < CLOCKS_PER_SEC / SEC_DIV; c++);

	checkPeriod = c / 100;

	return c * SEC_DIV;
}

int main(void)
{
	TryGetIncrementPerSec();
	TryGetIncrementPerSec();

	printf("This environment is capable of increment %lld times per second in simple loop.\n", TryGetIncrementPerSec());
}

----
1à»è„65535à»â∫ÇÃêÆêîÇ…Ç®Ç¢ÇƒÇªÇÍÇèâä˙ílÇ∆ÇµÇΩÉRÉâÉbÉcêîóÒÇ™ç≈èâÇ…1Ç…íBÇ∑ÇÈÇ‹Ç≈Ç…ÅuäÑÇÈ2ÅvÇçsÇ§âÒêîÇ™óBàÍÇÃÇ‡ÇÃ

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	//private const int N_MAX = 255;
	private const int N_MAX = 65535;
	//private const int N_MAX = 16777215;

	public static void Main()
	{
		Dictionary<int, int> dc2n = new Dictionary<int, int>();
		Dictionary<int, int> n2dc = new Dictionary<int, int>();

		for (int n = 1; n <= N_MAX; n++)
		{
			int dc = GetCollatzDivideCount(n);

			if (dc2n.ContainsKey(dc))
				dc2n[dc] = -1;
			else
				dc2n[dc] = n;
		}
		foreach (int dc in dc2n.Keys)
		{
			int n = dc2n[dc];

			if (n != -1)
				n2dc[n] = dc;
		}

		Console.WriteLine(string.Format("1 à»è„ {0} à»â∫ÇÃêÆêîÇ…Ç®Ç¢ÇƒÅAÇªÇÍÇèâä˙ílÇ∆ÇµÇΩÉRÉâÉbÉcêîóÒÇ™ç≈èâÇ… 1 Ç…íBÇ∑ÇÈÇ‹Ç≈Ç…ÅuäÑÇÈ2ÅvÇçsÇ§âÒêîÇ™óBàÍÇÃÇ‡ÇÃÅF", N_MAX));

		foreach (int n in n2dc.Keys.OrderBy(v => v))
			Console.WriteLine(string.Format("èâä˙íl {0} ÇÃÇ∆Ç´äÑÇÈ2Ç {1} âÒçsÇ§ÅBäÑÇÈ2ÇçsÇ§âÒêîÇ™ {2} âÒÇ∆Ç»ÇÈèâä˙ílÇÕ {3} à»äOÇ…(Ç±ÇÃîÕàÕÇ…ÇÕ)Ç»Ç¢ÅB", n, n2dc[n], n2dc[n], n));
	}

	private static int GetCollatzDivideCount(long n)
	{
		int dc = 0;

		while (n != 1)
		{
			if (n % 2 == 0)
			{
				n /= 2;
				dc++;
			}
			else
			{
				if ((long.MaxValue - 1) / 3 < n)
					throw new OverflowException();

				n *= 3;
				n++;
			}
		}
		return dc;
	}
}

----
PrimeVoid_k (2)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

// ====
// Eratosthenes
// ====

//	#define N 1875000000 // 3.0E+10 / 16
//	#define N 187500000 // 3.0E+9 / 16
//	#define N 18750000 // 3.0E+8 / 16
//	#define N 6250000 // 1.0E+8 / 16
	#define N 6250001 // (1.0E+8 + 16) / 16

#define N_P13 15015

void GetPrimes(int *p)
{
	unsigned char *t = (unsigned char *)malloc(N); // 8-bit uint array
	unsigned long c; // 64-bit uint
	unsigned long d; // 64-bit uint
	unsigned int i; // 32-bit uint

	if(!t)
		exit(1); // fatal

	memset(t, 0x00, N_P13);

//	printf("2\n");
	*p++ = 2;

	for (c = 3; c <= 13; c += 2)
	{
		if (c != 9)
		{
//			printf("%llu\n", c);
			*p++ = (int)c;

			for (d = c; d / 16 < N_P13; d += c * 2)
			{
				t[d / 16] |= 1 << d / 2 % 8;
			}
		}
	}
	for (i = N_P13; i + N_P13 <= N; i += N_P13)
	{
		memcpy(t + i, t, N_P13);
	}
	for (; i < N; i++)
	{
		t[i] = t[i - N_P13];
	}
	for (c = 17; c / 16 < N; c += 2)
	{
		if (!(t[c / 16] & (1 << c / 2 % 8)))
		{
//			printf("%llu\n", c);
			*p++ = (int)c;

			if (c < 0x100000000) // If c < 2^32
			{
				for(d = c * c; d / 16 < N; d += c * 2)
				{
					t[d / 16] |= 1 << d / 2 % 8;
				}
			}
		}
	}
	free(t);

	*p = 0; // put ender
}

// ====

static void PrintPrimeVoid(int *primes, int primeCount, int k)
{
	printf("2 à»è„ %d à»â∫ÇÃàŸÇ»ÇÈ 2 Ç¬ÇÃëfêîÇ…Ç¬Ç¢ÇƒÇªÇÃä‘Ç…Ç†ÇÈëfêîÇÃå¬êîÇ™ %d ñ¢ñûÇÃÇ‡ÇÃÇÃÇ§Çøç∑Ç™ç≈ëÂÇ∆Ç»ÇÈÇ‡ÇÃÇÕÅF\n", primes[primeCount - 1], k);

	int maxDiff = 0;

	for (int c = 0; c + k < primeCount; c++)
		if (maxDiff < primes[c + k] - primes[c])
			maxDiff = primes[c + k] - primes[c];

	for (int c = 0; c + k < primeCount; c++)
		if (maxDiff == primes[c + k] - primes[c])
			printf("%d Ç∆ %d ÇªÇÃç∑ÇÕ %d\n", primes[c], primes[c + k], primes[c + k] - primes[c]);

	printf("\n");
}

int main()
{
	int *primes = (int *)malloc(10000000 * sizeof(int)); // HACK: rough size
	int primeCount;
	int c;

	if (!primes)
		exit(1); // fatal

	GetPrimes(primes);
	for (c = 0; primes[c]; c++);
	primeCount = c;

	for (int k = 1; k <= 100; k++)
	{
		PrintPrimeVoid(primes, primeCount, k);
	}
}

----
PrimeVoid_k

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	//private const int RANGE_SCALE = 10000;
	//private const int RANGE_SCALE = 100000;
	//private const int RANGE_SCALE = 1000000;
	private const int RANGE_SCALE = 3000000;
	//private const int RANGE_SCALE = 10000000;
	//private const int RANGE_SCALE = 100000000;
	//private const int RANGE_SCALE = 1000000000;

	private static int[] Primes =
		Enumerable.Range(0, RANGE_SCALE).Where(n => IsPrime((ulong)n))
		.Concat(new int[] {
		Enumerable.Range(RANGE_SCALE, int.MaxValue - RANGE_SCALE).First(n => IsPrime((ulong)n)) })
		.ToArray();

	public static void Main()
	{
		for (int k = 1; k <= 100; k++)
			PrintPrimeVoid(k);
	}

	private static void PrintPrimeVoid(int k)
	{
		Console.WriteLine($"2 à»è„ {Primes[Primes.Length - 1]} à»â∫ÇÃàŸÇ»ÇÈ 2 Ç¬ÇÃëfêîÇ…Ç¬Ç¢ÇƒÇªÇÃä‘Ç…Ç†ÇÈëfêîÇÃå¬êîÇ™ {k} ñ¢ñûÇÃÇ‡ÇÃÇÃÇ§Çøç∑Ç™ç≈ëÂÇ∆Ç»ÇÈÇ‡ÇÃÇÕÅF");

		int maxDiff = Enumerable.Range(0, Primes.Length - k).Select(i => Primes[i + k] - Primes[i]).Max();

		foreach (int i in Enumerable.Range(0, Primes.Length - k))
			if (maxDiff == Primes[i + k] - Primes[i])
				Console.WriteLine($"{Primes[i]} Ç∆ {Primes[i + k]} ÇªÇÃç∑ÇÕ {Primes[i + k] - Primes[i]}");

		Console.WriteLine("");
	}

	// ====
	// MillerRabin
	// ====

	public static bool IsPrime(ulong n)
	{
		if (n <= 61)
			return new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61 }.Contains((uint)n);

		if (n % 2 == 0)
			return false;

		ulong d = n;
		int r;
		for (r = 0; ((d >>= 1) & 1) == 0; r++) ;

		// memo:
		// -- https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test
		// if n < 4,759,123,141, it is enough to test a = 2, 7, and 61;
		// if n < 18,446,744,073,709,551,616 = 2^64, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.

		if (n <= uint.MaxValue)
			return !new uint[] { 2, 7, 61 }
				.Any(x => !MillerRabinTest32(x, (uint)d, r, (uint)n));
		else
			return !new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 }
				.Any(x => !MillerRabinTest64((ulong)x, d, r, n));
	}

	private static bool MillerRabinTest32(uint x, uint d, int r, uint n)
	{
		x = ModPow32(x, d, n);

		if (x != 1 && x != n - 1)
		{
			for (int s = r; ; s--)
			{
				if (s <= 0)
					return false;

				x = (uint)(((ulong)x * x) % n);

				if (x == n - 1)
					break;
			}
		}
		return true;
	}

	private static uint ModPow32(uint b, uint e, uint m)
	{
		uint a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = (uint)(((ulong)a * b) % m);

			b = (uint)(((ulong)b * b) % m);
		}
		return a;
	}

	private static bool MillerRabinTest64(ulong x, ulong d, int r, ulong n)
	{
		x = ModPow64(x, d, n);

		if (x != 1 && x != n - 1)
		{
			for (int c = r; ; c--)
			{
				if (c <= 0)
					return false;

				x = ModPow64(x, 2, n);

				if (x == n - 1)
					break;
			}
		}
		return true;
	}

	private static ulong ModPow64(ulong b, ulong e, ulong m)
	{
		ulong a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModMul64(a, b, m);

			b = ModMul64(b, b, m);
		}
		return a;
	}

	private static ulong ModMul64(ulong b, ulong e, ulong m)
	{
		ulong a = 0;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModAdd64(a, b, m);

			b = ModAdd64(b, b, m);
		}
		return a;
	}

	private static ulong ModAdd64(ulong a, ulong b, ulong m)
	{
		ulong r = (ulong.MaxValue % m + 1) % m;

		while (ulong.MaxValue - a < b)
		{
			unchecked { a += b; }
			b = r;
		}
		return (a + b) % m;
	}

	// =====
}

----
Xorshift-64 ÉRÉsÉyóp

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		RndCtr = (ulong)DateTime.Now.Ticks;

		for (int c = 0; c < 100; c++)
		{
			Console.WriteLine(GetRandULong());
		}
	}

	// ====
	// Random
	// ====

	public static ulong RndCtr = 1;

	public static ulong GetRandULong()
	{
		RndCtr ^= RndCtr << 13;
		RndCtr ^= RndCtr >> 7;
		RndCtr ^= RndCtr << 17;
		return RndCtr;
	}

	// ====
}

----
Sin Cos from 0 to 90 degree Part2

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		D2Point[] Points = Enumerable.Range(0, 91).Select(dummy => new D2Point(0.0, 1.0)).ToArray();

		Points[0].X = 1.0;
		Points[0].Y = 0.0;

		for (int c = 0; c < 24000; c++)
		{
			for (int d = 1; d <= 89; d++)
			{
				Points[d] = (Points[d - 1] + Points[d + 1]) / 2.0;
				Points[d] /= GetDistance(Points[d]);
			}
		}

		for (int d = 0; d <= 90; d++)
		{
			Console.WriteLine($"Cos {d} degree is {Points[d].X:F12}");
			Console.WriteLine($"Sin {d} degree is {Points[d].Y:F12}");
		}
	}

	private static double GetDistance(D2Point pt)
	{
		return Math.Sqrt(pt.X * pt.X + pt.Y * pt.Y);
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----
IntSqrt UIntSqrt

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(uint.MaxValue - 3, (ulong)(uint.MaxValue - 3) * (uint.MaxValue - 3), (ulong)(uint.MaxValue - 2) * (uint.MaxValue - 2) - 1);
		Test01_a(uint.MaxValue - 2, (ulong)(uint.MaxValue - 2) * (uint.MaxValue - 2), (ulong)(uint.MaxValue - 1) * (uint.MaxValue - 1) - 1);
		Test01_a(uint.MaxValue - 1, (ulong)(uint.MaxValue - 1) * (uint.MaxValue - 1), (ulong)(uint.MaxValue - 0) * (uint.MaxValue - 0) - 1);
		Test01_a(uint.MaxValue - 0, (ulong)(uint.MaxValue - 0) * (uint.MaxValue - 0), ulong.MaxValue);

		Test01_b(10000, 100);
		Test01_b(10000, 10000);
		Test01_b(10000, 1000000);
		Test01_b(10000, 100000000);
		Test01_b(10000, 10000000000);
		Test01_b(10000, 1000000000000);
		Test01_b(10000, 100000000000000);
		Test01_b(10000, 10000000000000000);
		Test01_b(10000, 1000000000000000000);
		Test01_b(10000, 18440000000000000000);

		Test01_c(int.MaxValue - 3, (long)(int.MaxValue - 3) * (int.MaxValue - 3), (long)(int.MaxValue - 2) * (int.MaxValue - 2) - 1);
		Test01_c(int.MaxValue - 2, (long)(int.MaxValue - 2) * (int.MaxValue - 2), (long)(int.MaxValue - 1) * (int.MaxValue - 1) - 1);
		Test01_c(int.MaxValue - 1, (long)(int.MaxValue - 1) * (int.MaxValue - 1), (long)(int.MaxValue - 0) * (int.MaxValue - 0) - 1);
		Test01_c(int.MaxValue - 0, (long)(int.MaxValue - 0) * (int.MaxValue - 0), ((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) - 1);

		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 0));
		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 1));
		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 2));
		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 3));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 0));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 1));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 2));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 3));

		Test01_d(10000, 100);
		Test01_d(10000, 10000);
		Test01_d(10000, 1000000);
		Test01_d(10000, 100000000);
		Test01_d(10000, 10000000000);
		Test01_d(10000, 1000000000000);
		Test01_d(10000, 100000000000000);
		Test01_d(10000, 10000000000000000);
		Test01_d(10000, 1000000000000000000);
		Test01_d(10000, 4610000000000000000);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(uint expectRet, ulong minPrm, ulong maxPrm)
	{
		for (ulong prm = minPrm; ; prm++)
		{
			uint ret = UIntSqrt(prm);

			if (ret != expectRet)
				throw null; // BUG !!!

			// ----

			if (maxPrm <= prm)
				break;

			if (minPrm + 3000 < maxPrm) // ëΩÇ¢ -> íÜÉXÉLÉbÉv
				if (minPrm + 1000 < prm && prm < maxPrm - 1000)
					prm += (maxPrm - prm) / 2;
		}
		Console.WriteLine("OK");
	}

	private static void Test01_b(int testCount, ulong prmScale)
	{
		for (int testcnt = 0; testcnt < testCount; testcnt++)
		{
			ulong prm = GetULongRand() % prmScale;
			uint ret = UIntSqrt(prm);

			if ((ulong)ret * ret > prm)
				throw null; // BUG !!!

			if ((ulong)(ret + 1) * (ret + 1) <= prm)
				throw null; // BUG !!!
		}
		Console.WriteLine("OK");
	}

	private static void Test01_c(int expectRet, long minPrm, long maxPrm)
	{
		for (long prm = minPrm; ; prm++)
		{
			int ret = IntSqrt(prm);

			if (ret != expectRet)
				throw null; // BUG !!!

			// ----

			if (maxPrm <= prm)
				break;

			if (minPrm + 3000 < maxPrm) // ëΩÇ¢ -> íÜÉXÉLÉbÉv
				if (minPrm + 1000 < prm && prm < maxPrm - 1000)
					prm += (maxPrm - prm) / 2;
		}
		Console.WriteLine("OK");
	}

	private static void Test01_d(int testCount, long prmScale)
	{
		for (int testcnt = 0; testcnt < testCount; testcnt++)
		{
			long prm = (long)(GetULongRand() % (ulong)prmScale);
			int ret = IntSqrt(prm);

			if ((long)ret * ret > prm)
				throw null; // BUG !!!

			if ((long)(ret + 1) * (ret + 1) <= prm)
				throw null; // BUG !!!
		}
		Console.WriteLine("OK");
	}

	// ----

	public static Exception ToThrow(Action routine)
	{
		try
		{
			routine();
		}
		catch (Exception ex)
		{
			return ex;
		}
		throw new Exception("ó·äOÇìäÇ∞Ç‹ÇπÇÒÇ≈ÇµÇΩÅB");
	}

	public static void ToThrowPrint(Action routine)
	{
		Console.WriteLine("ëzíËÇ≥ÇÍÇΩó·äOÅF" + ToThrow(routine).Message);
	}

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	// ====
	// ====
	// ====

	public static int IntSqrt(long value)
	{
		if (value < 0 || (1L << 62) <= value)
			throw new ArgumentException();

		return (int)UIntSqrt((ulong)value);
	}

#if true
		public static uint UIntSqrt(ulong value)
		{
			uint ret = 0;

			for (uint bit = 1u << 31; bit != 0; bit >>= 1)
			{
				uint m = ret | bit;

				if ((ulong)m * m <= value)
					ret = m;
			}
			return ret;
		}
#else
	public static uint UIntSqrt(ulong value)
	{
		ulong l = 0;
		ulong r = (ulong)uint.MaxValue + 1;

		while (l + 1 < r)
		{
			ulong m = (l + r) / 2;

			if (m * m <= value)
				l = m;
			else
				r = m;
		}
		return (uint)l;
	}
#endif
}

----
Sin Cos from 0 to 90 degree (Queue)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		Queue<AngleInfo> angles = new Queue<AngleInfo>(new AngleInfo[]
		{
			new AngleInfo() { Degree =  0.0, Point = new D2Point(1.0, 0.0) },
			new AngleInfo() { Degree = 90.0, Point = new D2Point(0.0, 1.0) },
			null, // ender
		});

		Subdivide(angles, 10);

		foreach (AngleInfo angle in angles)
		{
			Console.WriteLine($"Cos {angle.Degree:F9} degree is {angle.Point.X:F15}");
			Console.WriteLine($"Sin {angle.Degree:F9} degree is {angle.Point.Y:F15}");
		}
	}

	private static void Subdivide(Queue<AngleInfo> angles, int depth)
	{
		AngleInfo last = angles.Dequeue();

		for (; ; )
		{
			AngleInfo next = angles.Dequeue();

			if (next == null) // is ender
			{
				angles.Enqueue(last);

				if (--depth <= 0)
					break;

				angles.Enqueue(null); // put ender
				last = angles.Dequeue();
				continue;
			}

			double mDeg = (last.Degree + next.Degree) / 2.0;
			D2Point mPt = (last.Point + next.Point) / 2.0;
			double d = M_Sqrt(mPt.X * mPt.X + mPt.Y * mPt.Y);
			mPt /= d;

			angles.Enqueue(last);
			angles.Enqueue(new AngleInfo() { Degree = mDeg, Point = mPt });

			last = next;
		}
	}

	/*
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv <= value)
				l = m;
			else
				r = m;
		}
		return l;
	}
	/*/
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv < value)
				l = m;
			else
				r = m;
		}

		{
			double m = (l + r) / 2.0;

			return m;
		}
	}
	//*/

	private class AngleInfo
	{
		public double Degree;
		public D2Point Point;
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----

public class Hello
{
	public static void Main()
	{ }
}

----
Sin Cos from 0 to 90 degree

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		IEnumerable<AngleInfo> angles = new AngleInfo[]
		{
			new AngleInfo() { Degree =  0.0, Point = new D2Point(1.0, 0.0) },
			new AngleInfo() { Degree = 90.0, Point = new D2Point(0.0, 1.0) },
		};

		for (int c = 0; c < 10; c++)
			angles = Subdivide(angles);

		foreach (AngleInfo angle in angles)
		{
			Console.WriteLine($"Cos {angle.Degree:F9} degree is {angle.Point.X:F15}");
			Console.WriteLine($"Sin {angle.Degree:F9} degree is {angle.Point.Y:F15}");
		}
	}

	private static IEnumerable<AngleInfo> Subdivide(IEnumerable<AngleInfo> angles)
	{
		IEnumerator<AngleInfo> reader = angles.GetEnumerator();

		if (!reader.MoveNext())
			throw new Exception("angles is empty");

		AngleInfo last = reader.Current;

		while (reader.MoveNext())
		{
			AngleInfo next = reader.Current;

			double mDeg = (last.Degree + next.Degree) / 2.0;
			D2Point mPt = (last.Point + next.Point) / 2.0;
			double d = M_Sqrt(mPt.X * mPt.X + mPt.Y * mPt.Y);
			mPt /= d;

			yield return last;
			yield return new AngleInfo() { Degree = mDeg, Point = mPt };

			last = next;
		}
		yield return last;
	}

	/*
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv <= value)
				l = m;
			else
				r = m;
		}
		return l;
	}
	/*/
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv < value)
				l = m;
			else
				r = m;
		}

		{
			double m = (l + r) / 2.0;

			return m;
		}
	}
	//*/

	private class AngleInfo
	{
		public double Degree;
		public D2Point Point;
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		Test01();
		//Test02();
	}

	private static void Test01()
	{
		for (double degree = 0.0; degree < 360.0; degree += 1.0)
		//for (double degree = 0.0; degree < 360.0; degree += 0.1)
		{
			double rad = degree * Math.PI / 180.0;

			double s1 = Sin(degree);
			double s2 = Math.Sin(rad);

			double c1 = Cos(degree);
			double c2 = Math.Cos(rad);

			double t1 = Tan(degree);
			double t2 = Math.Tan(rad);

			Console.WriteLine(string.Format("{0:F1} ìxÇÃÇ∆Ç´ÇÃåÎç∑ ==> Sin : {1:F20} , Cos : {2:F20} , Tan : {3:F20}"
				, degree
				, Math.Abs(s1 - s2)
				, Math.Abs(c1 - c2)
				, Math.Abs(t1 - t2)
				));
		}
	}

	private static void Test02()
	{
		for (double value = 0.0; value < 10.0; value += 0.10)
		//for (double value = 0.0; value < 10.0; value += 0.01)
		{
			double r1 = M_Sqrt(value);
			double r2 = Math.Sqrt(value);

			Console.WriteLine(string.Format("{0:F2} ÇÃïΩï˚ç™ÇÃåÎç∑ ==> {1:F20}"
				, value
				, Math.Abs(r1 - r2)
				));
		}
	}

	// ----
	// ----
	// ----

	public static double Tan(double degree)
	{
		return Sin(degree) / Cos(degree);
	}

	public static double Sin(double degree)
	{
		return Cos(degree - 90.0);
	}

	public static double Cos(double degree)
	{
		while (degree < 0.0)
			degree += 360.0;

		while (360.0 < degree)
			degree -= 360.0;

		return M_Cos(degree);
	}

	private static double M_Cos(double degree)
	{
		if (180.0 < degree)
			return M_Cos(360.0 - degree);

		if (90.0 < degree)
			return M_Cos(180.0 - degree) * -1.0;

		D2Point lPt = new D2Point(1.0, 0.0);
		D2Point rPt = new D2Point(0.0, 1.0);
		double lDeg = 0.0;
		double rDeg = 90.0;

		for (int c = 0; c < 50; c++)
		{
			D2Point mPt = (lPt + rPt) / 2.0;
			double d = M_Sqrt(mPt.X * mPt.X + mPt.Y * mPt.Y);
			mPt /= d;
			double mDeg = (lDeg + rDeg) / 2.0;

			if (mDeg < degree)
			{
				lPt = mPt;
				lDeg = mDeg;
			}
			else
			{
				rPt = mPt;
				rDeg = mDeg;
			}
		}

		{
			D2Point mPt = (lPt + rPt) / 2.0;

			return mPt.X;
		}
	}

	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = Math.Max(1.0, value);

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv < value)
				l = m;
			else
				r = m;
		}

		{
			double m = (l + r) / 2.0;

			return m;
		}
	}

	// ====

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----
IEqualityComparer<int[]> Çé¿ëïÇ∑ÇÈÅB

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(2);
		Test01_a(3);
		Test01_a(5);
		Test01_a(7);
		Test01_a(11);
		Test01_a(13);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(int valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<int[]> hs2 = new HashSet<int[]>(new IntsIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			int[] value = GetRandIntList(GetRandInt(valueScale));
			string strValue = ToString(value);

			bool c1 = hs1.Contains(strValue);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(strValue);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(strValue);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	// IntîzóÒ -> ï∂éöóÒ
	private static string ToString(int[] arr)
	{
		return string.Join("_", arr);
	}

	public class IntsIEC : IEqualityComparer<int[]>
	{
		public bool Equals(int[] a, int[] b)
		{
			if (a.Length != b.Length)
				return false;

			for (int index = 0; index < a.Length; index++)
				if (a[index] != b[index])
					return false;

			return true;
		}

		public int GetHashCode(int[] a)
		{
		    // HACK: HachCode.Combine Ç…Ç±Ç§Ç¢Ç§égÇ¢ï˚Ç™ëzíËÇ≥ÇÍÇƒÇ¢ÇÈÇÃÇ©ã^ñ‚ÅB

			int digest = 0;

			foreach (int value in a)
				digest = HashCode.Combine(digest, value);

			return digest;
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetULongRand() % (ulong)modulo);
	}

	private static int[] GetRandIntList(int size)
	{
		int[] arr = new int[size];

		for (int index = 0; index < size; index++)
			arr[index] = (int)(uint)GetULongRand();

		return arr;
	}

	// ====

	// Ç»ÇÒÇ© HashCode ñ≥Ç¢Ç¡Ç€Ç¢ÇÃÇ≈ÅAÉ_É~Å[Çé¿ëïÇµÇƒÇ®Ç≠ÅB
	// .NET Core 2.1 (2018) à»ç~Ç…ÇÕÇ†ÇÈÇ¡Ç€Ç¢ÅB
	public static class HashCode
	{
		public static int Combine(int a, int b)
		{
			ulong x = (ulong)(uint)a;
			ulong y = (ulong)(uint)b;

			x = ((x << 32) | y) % 4294967291;

			return (int)(uint)x;
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		string version = typeof(System.String).Assembly.GetName().Version.ToString();

		//string version = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription;

		Console.WriteLine(version);
	}
}

----
Adler32 ÇégÇ¡Çƒ IEqualityComparer<byte[]> Çé¿ëïÇ∑ÇÈÅB

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test02_a(2);
		Test02_a(3);
		Test02_a(5);
		Test02_a(7);

		Console.WriteLine("OK!");
	}

	private static void Test02_a(int valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<byte[]> hs2 = new HashSet<byte[]>(new Adler32BytesIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			byte[] value = GetRandBytes(GetRandInt(valueScale));
			string strValue = ToString(value);

			bool c1 = hs1.Contains(strValue);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(strValue);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(strValue);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	// ÉoÉCÉgóÒ -> Hexï∂éöóÒ
	private static string ToString(byte[] data)
	{
		return string.Join("", data.Select(v => v.ToString("x2")));
	}

	public class Adler32BytesIEC : IEqualityComparer<byte[]>
	{
		public bool Equals(byte[] a, byte[] b)
		{
			if (a.Length != b.Length)
				return false;

			for (int index = 0; index < a.Length; index++)
				if (a[index] != b[index])
					return false;

			return true;
		}

		public int GetHashCode(byte[] a)
		{
			return (int)Adler32.ComputeHash(a);
		}
	}

	public static class Adler32
	{
		private const uint MODULO = 65521;

		public static uint ComputeHash(IEnumerable<byte> data)
		{
			uint a = 1;
			uint b = 0;

			foreach (byte c in data)
			{
				a = (a + c) % MODULO;
				b = (b + a) % MODULO;
			}
			return a | (b << 16);
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetULongRand() % (ulong)modulo);
	}

	private static byte[] GetRandBytes(int size)
	{
		byte[] data = new byte[size];
		Csprng.GetBytes(data);
		return data;
	}

	// ====
}

----
Adler32 ÇégÇ¡Çƒ IEqualityComparer<string> Çé¿ëïÇ∑ÇÈÅB

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(10);
		Test01_a(100);
		Test01_a(1000);
		Test01_a(10000);
		Test01_a(100000);
		Test01_a(1000000);
		Test01_a(10000000);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(ulong valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<string> hs2 = new HashSet<string>(new Adler32StringIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			string value = (GetULongRand() % valueScale).ToString();

			bool c1 = hs1.Contains(value);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(value);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(value);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	public class Adler32StringIEC : IEqualityComparer<string>
	{
		public bool Equals(string a, string b)
		{
			return a == b;
		}

		public int GetHashCode(string a)
		{
			return (int)Adler32.ComputeHash(Encoding.UTF8.GetBytes(a));
		}
	}

	public static class Adler32
	{
		private const uint MODULO = 65521;

		public static uint ComputeHash(IEnumerable<byte> data)
		{
			uint a = 1;
			uint b = 0;

			foreach (byte c in data)
			{
				a = (a + c) % MODULO;
				b = (b + a) % MODULO;
			}
			return a | (b << 16);
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	// ====
}

----
ëgçáÇπ Combination

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		//Test01(5, 3);
		Test01(10, 4);
	}

	private static void Test01(int n, int r)
	{
		Console.WriteLine($"{n} å¬ (0 .. {n - 1}) ÇÃíÜÇ©ÇÁ {r} å¬ëIÇ‘ {Combination(n, r).Count()} í ÇËÇÃëgçáÇπÇÕà»â∫ÇÃÇ∆Ç®ÇËÅB");

		foreach (int[] indexes in Combination(n, r))
			Console.WriteLine($"({string.Join(", ", indexes)})");
	}

	// ----

	public static IEnumerable<int[]> Combination(int n, int r)
	{
		if (r < 1 || n < r)
			throw new Exception(); // Bad params

		int[] indexes = Enumerable.Range(0, r).ToArray();

		for (; ; )
		{
			yield return indexes;

			for (int d = 0; ; d++)
			{
				indexes[d]++;

				if (d + 1 < r)
				{
					if (indexes[d] < indexes[d + 1])
						break;
				}
				else
				{
					if (indexes[d] < n)
						break;

					yield break;
				}

				if (1 <= d)
					indexes[d] = indexes[d - 1] + 1;
				else
					indexes[d] = 0;
			}
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			ulong a = GetULongRand();
			ulong b = GetULongRand();
			ulong m = GetULongRandNonZero();
			ulong c = ModPow64(a, b, m);

			Console.WriteLine("ModPow ( " + a + " , " + b + " , " + m + " ) == " + c);
		}
	}

	private static ulong ModPow64(ulong b, ulong e, ulong m)
	{
		ulong a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModMul64(a, b, m);

			b = ModMul64(b, b, m);
		}
		return a % m;
	}

	private static ulong ModMul64(ulong b, ulong e, ulong m)
	{
		ulong a = 0;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModAdd64(a, b, m);

			b = ModAdd64(b, b, m);
		}
		return a;
	}

	private static ulong ModAdd64(ulong a, ulong b, ulong m)
	{
		ulong r = (ulong.MaxValue % m + 1) % m;

		while (ulong.MaxValue - a < b)
		{
			unchecked { a += b; }
			b = r;
		}
		return (a + b) % m;
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static ulong GetULongRandNonZero()
	{
		ulong value;

		do
		{
			value = GetULongRand();
		}
		while (value == 0);

		return value;
	}

	// ====
}

----
êºóÔì˙ïtÇ©ÇÁójì˙ÇéÊìæÇ∑ÇÈÅB

#include <stdio.h>

int DateToDay(int y, int m, int d)
{
	int day;

	if (m <= 2)
	{
		y--;
	}
	day = y / 400;
	day *= 365 * 400 + 97;
	y %= 400;
	day += y * 365;
	day += y / 4;
	day -= y / 100;

	if (2 < m)
	{
		day -= 31 * 10 - 4;
		m -= 3;
		day += (m / 5) * (31 * 5 - 2);
		m %= 5;
		day += (m / 2) * (31 * 2 - 1);
		m %= 2;
		day += m * 31;
	}
	else
	{
		day += (m - 1) * 31;
	}
	day += d - 1;

	return day;
}

char *DateToWeekday(int y, int m, int d)
{
	static char *weekdays[] =
	{
		"åé", "âŒ", "êÖ", "ñÿ", "ã‡", "ìy", "ì˙"
	};

	return weekdays[DateToDay(y, m, d) % 7];
}

// ----

static void Test01(int y, int m, int d)
{
	printf("êºóÔ%04dîN%02dåé%02dì˙ÇÕ%sójì˙Ç≈Ç∑ÅB\n", y, m, d, DateToWeekday(y, m, d));
}

int main(void)
{
	Test01(1970,  1,  1);
	Test01(1999, 12, 31);
	Test01(2000,  1,  1);
	Test01(2000, 12, 31);
	Test01(2001,  1,  1);
	Test01(2013,  4, 15);
	Test01(2022, 10, 18);
	Test01(2222,  2,  2);
}

----
êºóÔì˙ïtÇòaóÔÇ…ïœä∑Ç∑ÇÈÅB

#include <stdio.h>
#include <stdlib.h> // for rand()
#include <time.h> // for srand SEED

typedef struct EraInfo_st
{
	int FirstYMD;
	char *Name;
}
EraInfo_t;

extern EraInfo_t EraInfos[];
extern size_t EraInfosLen;

void DateToJapaneseDate(int y, int m, int d, char **pName, char **pNen)
{
	int l = 0;
	int r = EraInfosLen;
	EraInfo_t *i;

	while (l + 1 < r)
	{
		int mid = (l + r) / 2;

		if (EraInfos[mid].FirstYMD <= y * 10000 + m * 100 + d)
			l = mid;
		else
			r = mid;
	}

	i = EraInfos + l;

	if (i->Name)
	{
		*pName = i->Name;
		y -= i->FirstYMD / 10000 - 1;
	}
	else
	{
		*pName = "êºóÔ";
	}

	if (2 <= y)
	{
		static char nenBuff[11];

		*pNen = nenBuff;
		sprintf(nenBuff, "%d", y);
	}
	else
	{
		*pNen = "å≥";
	}
}

// ----

static void Test01(int y, int m, int d)
{
	char *name;
	char *nen;

	DateToJapaneseDate(y, m, d, &name, &nen);

	printf("êºóÔ%04dîN%02dåé%02dì˙ÇÕ%s%sîN%02dåé%02dì˙Ç≈Ç∑ÅB\n", y, m, d, name, nen, m, d);
}

static void Test02(void)
{
	int c;

	srand(time(NULL));

	for (c = 0; c < 1000; c++)
	{
		int y = rand() % 3000 + 1;
		int m = rand() % 12 + 1;
		int d = rand() % 28 + 1;

		Test01(y, m, d);
	}
}

int main(void)
{
	Test01(1865,  5,  1);
	Test01(1867, 12, 31);
	Test01(1868,  1,  1);
	Test01(1912,  7, 29);
	Test01(1912,  7, 30);
	Test01(1926, 12, 24);
	Test01(1926, 12, 25);
	Test01(1989,  1,  7);
	Test01(1989,  1,  8);
	Test01(2019,  4, 30);
	Test01(2019,  5,  1);
	Test01(2022, 10, 18);

	Test02();
}

// ----

EraInfo_t EraInfos[] =
{
	{        0, NULL   },
	{  6450717, "ëÂâª" },
	{  6500322, "îíË≥" },
	{  6541124, NULL   },
	{  6860814, "éÈíπ" },
	{  6861001, NULL   },
	{  7010503, "ëÂïÛ" },
	{  7040616, "åcâ_" },
	{  7080207, "òaì∫" },
	{  7151003, "óÏãT" },
	{  7171224, "ó{òV" },
	{  7240303, "ê_ãT" },
	{  7290902, "ìVïΩ" },
	{  7490504, "ìVïΩä¥ïÛ" },
	{  7490819, "ìVïΩèüïÛ" },
	{  7570906, "ìVïΩïÛéö" },
	{  7650201, "ìVïΩê_åÏ" },
	{  7670913, "ê_åÏåiâ_" },
	{  7701023, "ïÛãT" },
	{  7810130, "ìVâû" },
	{  7820930, "âÑóÔ" },
	{  8060608, "ëÂìØ" },
	{  8101020, "çOêm" },
	{  8240208, "ìVí∑" },
	{  8340214, "è≥òa" },
	{  8480716, "â√èÀ" },
	{  8510601, "êméı" },
	{  8541223, "êƒçt" },
	{  8570320, "ìVà¿" },
	{  8590520, "íÂäœ" },
	{  8770601, "å≥åc" },
	{  8850311, "êmòa" },
	{  8890530, "ä∞ïΩ" },
	{  8980520, "èπë◊" },
	{  9010831, "âÑäÏ" },
	{  9230529, "âÑí∑" },
	{  9310516, "è≥ïΩ" },
	{  9380622, "ìVåc" },
	{  9470515, "ìVóÔ" },
	{  9571121, "ìVìø" },
	{  9610305, "âûòa" },
	{  9640819, "çNï€" },
	{  9680908, "à¿òa" },
	{  9700503, "ìVò\" },
	{  9740116, "ìVâÑ" },
	{  9760811, "íÂå≥" },
	{  9781231, "ìVå≥" },
	{  9830529, "âiäœ" },
	{  9850519, "ä∞òa" },
	{  9870505, "âiâÑ" },
	{  9890910, "âi‚N" },
	{  9901126, "ê≥óÔ" },
	{  9950325, "í∑ìø" },
	{  9990201, "í∑ï€" },
	{ 10040808, "ä∞çO" },
	{ 10130208, "í∑òa" },
	{ 10170521, "ä∞êm" },
	{ 10210317, "é°à¿" },
	{ 10240819, "ñúéı" },
	{ 10280818, "í∑å≥" },
	{ 10370509, "í∑óÔ" },
	{ 10401216, "í∑ãv" },
	{ 10441216, "ä∞ìø" },
	{ 10460522, "âiè≥" },
	{ 10530202, "ìVäÏ" },
	{ 10580919, "çNïΩ" },
	{ 10650904, "é°óÔ" },
	{ 10690506, "âÑãv" },
	{ 10740916, "è≥ï€" },
	{ 10771205, "è≥óÔ" },
	{ 10810322, "âiï€" },
	{ 10840315, "âûìø" },
	{ 10870511, "ä∞é°" },
	{ 10950123, "â√ï€" },
	{ 10970103, "âií∑" },
	{ 10971227, "è≥ìø" },
	{ 10990915, "çNòa" },
	{ 11040308, "í∑é°" },
	{ 11060513, "â√è≥" },
	{ 11080909, "ìVêm" },
	{ 11100731, "ìVâi" },
	{ 11130825, "âiãv" },
	{ 11180425, "å≥âi" },
	{ 11200509, "ï€à¿" },
	{ 11240518, "ìVé°" },
	{ 11260215, "ëÂé°" },
	{ 11310228, "ìVè≥" },
	{ 11320921, "í∑è≥" },
	{ 11350610, "ï€âÑ" },
	{ 11410813, "âié°" },
	{ 11420525, "çNé°" },
	{ 11440328, "ìVó{" },
	{ 11450812, "ãvà¿" },
	{ 11510214, "êmïΩ" },
	{ 11541204, "ãvéı" },
	{ 11560518, "ï€å≥" },
	{ 11590509, "ïΩé°" },
	{ 11600218, "âióÔ" },
	{ 11610924, "âûï€" },
	{ 11630504, "í∑ä∞" },
	{ 11650714, "âiñú" },
	{ 11660923, "êmà¿" },
	{ 11690506, "â√âû" },
	{ 11710527, "è≥à¿" },
	{ 11750816, "à¿å≥" },
	{ 11770829, "é°è≥" },
	{ 11810825, "ó{òa" },
	{ 11820629, "éıâi" },
	{ 11840527, "å≥óÔ" },
	{ 11850909, "ï∂é°" },
	{ 11900516, "åöãv" },
	{ 11990523, "ê≥é°" },
	{ 12010319, "åöêm" },
	{ 12040323, "å≥ãv" },
	{ 12060605, "åöâi" },
	{ 12071116, "è≥å≥" },
	{ 12110423, "åöóÔ" },
	{ 12140118, "åöï€" },
	{ 12190527, "è≥ãv" },
	{ 12220525, "íÂâû" },
	{ 12241231, "å≥êm" },
	{ 12250528, "â√ò\" },
	{ 12280118, "à¿íÂ" },
	{ 12290331, "ä∞äÏ" },
	{ 12320423, "íÂâi" },
	{ 12330525, "ìVïü" },
	{ 12341127, "ï∂óÔ" },
	{ 12351101, "â√íı" },
	{ 12381230, "óÔêm" },
	{ 12390313, "âÑâû" },
	{ 12400805, "êmé°" },
	{ 12430318, "ä∞å≥" },
	{ 12470405, "ïÛé°" },
	{ 12490502, "åöí∑" },
	{ 12561024, "çNå≥" },
	{ 12570331, "ê≥â√" },
	{ 12590420, "ê≥å≥" },
	{ 12600524, "ï∂âû" },
	{ 12610322, "çOí∑" },
	{ 12640327, "ï∂âi" },
	{ 12750522, "åöé°" },
	{ 12780323, "çOà¿" },
	{ 12880529, "ê≥âû" },
	{ 12930906, "âiêm" },
	{ 12990525, "ê≥à¿" },
	{ 13021210, "ä£å≥" },
	{ 13030916, "â√å≥" },
	{ 13070118, "ìøé°" },
	{ 13081122, "âÑåc" },
	{ 13110517, "âûí∑" },
	{ 13120427, "ê≥òa" },
	{ 13170316, "ï∂ï€" },
	{ 13190518, "å≥âû" },
	{ 13210322, "å≥ãú" },
	{ 13241225, "ê≥íÜ" },
	{ 13260528, "â√óÔ" },
	{ 13290922, "å≥ìø" },
	{ 13310911, "å≥çO" },
	{ 13320523, "ê≥åc" },
	{ 13340305, "åöïê" },
	{ 13360411, "âÑå≥" },
	{ 13400525, "ãªçë" },
	{ 13470120, "ê≥ïΩ" },
	{ 13700816, "åöìø" },
	{ 13720500, "ï∂íÜ" },
	{ 13750626, "ìVéˆ" },
	{ 13810306, "çOòa" },
	{ 13840518, "å≥íÜ" },
	{ 13381011, "óÔâû" },
	{ 13420601, "çNâi" },
	{ 13451115, "íÂòa" },
	{ 13500404, "äœâû" },
	{ 13521104, "ï∂òa" },
	{ 13560429, "âÑï∂" },
	{ 13610504, "çNà¿" },
	{ 13621011, "íÂé°" },
	{ 13680307, "âûà¿" },
	{ 13750329, "âiòa" },
	{ 13790409, "çNóÔ" },
	{ 13810320, "âiìø" },
	{ 13840319, "éäìø" },
	{ 13871005, "â√åc" },
	{ 13890307, "çNâû" },
	{ 13900412, "ñæìø" },
	{ 13940802, "âûâi" },
	{ 14280610, "ê≥í∑" },
	{ 14291003, "âiãù" },
	{ 14410310, "â√ãg" },
	{ 14440223, "ï∂à¿" },
	{ 14490816, "ïÛìø" },
	{ 14520810, "ãùìø" },
	{ 14550906, "çNê≥" },
	{ 14571016, "í∑ò\" },
	{ 14610201, "ä∞ê≥" },
	{ 14660314, "ï∂ê≥" },
	{ 14670409, "âûêm" },
	{ 14690608, "ï∂ñæ" },
	{ 14870809, "í∑ãù" },
	{ 14890916, "âÑìø" },
	{ 14920812, "ñæâû" },
	{ 15010318, "ï∂ãT" },
	{ 15040316, "âiê≥" },
	{ 15210923, "ëÂâi" },
	{ 15280903, "ãùò\" },
	{ 15320829, "ìVï∂" },
	{ 15551107, "çOé°" },
	{ 15580318, "âiò\" },
	{ 15700527, "å≥ãT" },
	{ 15730825, "ìVê≥" },
	{ 15930110, "ï∂ò\" },
	{ 15961216, "åcí∑" },
	{ 16150905, "å≥òa" },
	{ 16240417, "ä∞âi" },
	{ 16450113, "ê≥ï€" },
	{ 16480407, "åcà¿" },
	{ 16521020, "è≥âû" },
	{ 16550518, "ñæóÔ" },
	{ 16580821, "ñúé°" },
	{ 16610523, "ä∞ï∂" },
	{ 16731030, "âÑïÛ" },
	{ 16811109, "ìVòa" },
	{ 16840405, "íÂãù" },
	{ 16881023, "å≥ò\" },
	{ 17040416, "ïÛâi" },
	{ 17110611, "ê≥ìø" },
	{ 17160809, "ãùï€" },
	{ 17360607, "å≥ï∂" },
	{ 17410412, "ä∞ï€" },
	{ 17440403, "âÑãù" },
	{ 17480805, "ä∞âÑ" },
	{ 17511214, "ïÛóÔ" },
	{ 17640630, "ñæòa" },
	{ 17721210, "à¿âi" },
	{ 17810425, "ìVñæ" },
	{ 17890219, "ä∞ê≠" },
	{ 18010319, "ãùòa" },
	{ 18040322, "ï∂âª" },
	{ 18180526, "ï∂ê≠" },
	{ 18310123, "ìVï€" },
	{ 18450109, "çOâª" },
	{ 18480401, "â√âi" },
	{ 18550115, "à¿ê≠" },
	{ 18600408, "ñúâÑ" },
	{ 18610329, "ï∂ãv" },
	{ 18640327, "å≥é°" },
	{ 18650501, "åcâû" },
	{ 18680101, "ñæé°" },
	{ 19120730, "ëÂê≥" },
	{ 19261225, "è∫òa" },
	{ 19890108, "ïΩê¨" },
	{ 20190501, "óﬂòa" },
};

size_t EraInfosLen = sizeof(EraInfos) / sizeof(EraInfo_t);

----
êºóÔ1/1/1Ç©ÇÁÇÃì˙êîÇêºóÔì˙ïtÇ…ïœä∑Ç∑ÇÈÅB

#include <stdio.h>

void DayToDate(int day, int *py, int *pm, int *pd)
{
	int y = day;
	int m = 1;
	int d;
	int w;

	y /= 146097;
	y *= 400;
	y += 1;
	day %= 146097;
	w = (day + 306) / 36524;
	day += w < 3 ? w : 3;
	y += (day / 1461) * 4;
	day %= 1461;
	w = (day + 306) / 365;
	day += w < 3 ? w : 3;
	y += day / 366;
	day %= 366;

	if (60 <= day)
	{
		m += 2;
		day -= 60;
		m += (day / 153) * 5;
		day %= 153;
		m += (day / 61) * 2;
		day %= 61;
	}
	m += day / 31;
	day %= 31;
	d = day + 1;

	*py = y;
	*pm = m;
	*pd = d;
}

// ----

#define IsUrudoshi(y) \
	(y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))

static void Error(void)
{
	printf("Error\n");
	exit(1);
}

static int GetDayOfMonth(int y, int m)
{
	switch (m)
	{
	case  1: return 31;
	case  2: return IsUrudoshi(y) ? 29 : 28;
	case  3: return 31;
	case  4: return 30;
	case  5: return 31;
	case  6: return 30;
	case  7: return 31;
	case  8: return 31;
	case  9: return 30;
	case 10: return 31;
	case 11: return 30;
	case 12: return 31;

	default:
		Error();
	}
}

static void Test02(void)
{
	int y = 1;
	int m = 1;
	int d = 1;
	int day = 0;

	while (y < 10000)
	{
		int ry;
		int rm;
		int rd;

		DayToDate(day, &ry, &rm, &rd);

		//if (day % 10000 == 0) printf("%d/%d/%d (%d) -> %d/%d/%d\n", y, m, d, day, ry, rm, rd);

		if (ry != y)
			Error();

		if (rm != m)
			Error();

		if (rd != d)
			Error();

		#define DAY_STEP 13

		d   += DAY_STEP;
		day += DAY_STEP;

		#undef DAY_STEP

		{
			int dom = GetDayOfMonth(y, m);

			if (dom < d)
			{
				d -= dom;
				m++;

				if (12 < m)
				{
					m = 1;
					y++;
				}
			}
		}
	}
}

static void Test01(int day)
{
	int y;
	int m;
	int d;

	DayToDate(day, &y, &m, &d);

	printf("(ÉOÉåÉSÉäÉIóÔä∑éZÇ≈)êºóÔ1îN1åé1ì˙Ç©ÇÁêîÇ¶Çƒ%dì˙å„ÇÕêºóÔ%04dîN%02dåé%02dì˙Ç≈Ç∑ÅB\n", day, y, m, d);
}

int main(void)
{
	//Test02();

	Test01(0);
	Test01(1000);
	Test01(10000);
	Test01(100000);
	Test01(1000000);
	Test01(1500000);
	Test01(2000000);
	Test01(2500000);
}

----
êºóÔì˙ïtÇêºóÔ1/1/1Ç©ÇÁÇÃì˙êîÇ…ïœä∑Ç∑ÇÈÅB

#include <stdio.h>

int DateToDay(int y, int m, int d)
{
	int day;

	if (m <= 2)
	{
		y--;
	}
	day = y / 400;
	day *= 365 * 400 + 97;
	y %= 400;
	day += y * 365;
	day += y / 4;
	day -= y / 100;

	if (2 < m)
	{
		day -= 31 * 10 - 4;
		m -= 3;
		day += (m / 5) * (31 * 5 - 2);
		m %= 5;
		day += (m / 2) * (31 * 2 - 1);
		m %= 2;
		day += m * 31;
	}
	else
	{
		day += (m - 1) * 31;
	}
	day += d - 1;

	return day;
}

// ----

#define IsUrudoshi(y) \
	(y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))

static void Error(void)
{
	printf("Error\n");
	exit(1);
}

static int GetDayOfMonth(int y, int m)
{
	switch (m)
	{
	case  1: return 31;
	case  2: return IsUrudoshi(y) ? 29 : 28;
	case  3: return 31;
	case  4: return 30;
	case  5: return 31;
	case  6: return 30;
	case  7: return 31;
	case  8: return 31;
	case  9: return 30;
	case 10: return 31;
	case 11: return 30;
	case 12: return 31;

	default:
		Error();
	}
}

static void Test02(void)
{
	int y = 1;
	int m = 1;
	int d = 1;
	int day = 0;

	while (y < 10000)
	{
		int ret = DateToDay(y, m, d);

		//if (ret % 10000 == 0) printf("%d/%d/%d (%d) -> %d\n", y, m, d, day, ret);

		if (ret != day)
			Error();

		#define DAY_STEP 13

		d   += DAY_STEP;
		day += DAY_STEP;

		#undef DAY_STEP

		{
			int dom = GetDayOfMonth(y, m);

			if (dom < d)
			{
				d -= dom;
				m++;

				if (12 < m)
				{
					m = 1;
					y++;
				}
			}
		}
	}
}

static void Test01(int y, int m, int d)
{
	printf("êºóÔ%04dîN%02dåé%02dì˙ÇÕ(ÉOÉåÉSÉäÉIóÔä∑éZÇ≈)êºóÔ1îN1åé1ì˙Ç©ÇÁêîÇ¶Çƒ%dì˙å„Ç≈Ç∑ÅB\n", y, m, d, DateToDay(y, m, d));
}

int main(void)
{
	//Test02();

	Test01(   1,  1,  1);
	Test01(  10,  1,  1);
	Test01( 100,  1,  1);
	Test01(1000,  1,  1);
	Test01(1970,  1,  1);
	Test01(1999, 12, 31);
	Test01(2013,  4, 15);
	Test01(2022, 10, 18);
}

----

#include <stdio.h>

int main(void)
{
	printf("Hello, Happy World!\n");
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Comparison<int> comp = (a, b) => a - b;

		for (int testcnt = 0; testcnt < 3000; testcnt++)
		{
			int[] arr = GetRandIntList().ToArray();
			int target = GetRandInt(100);

			Array.Sort(arr, comp);

			int[] range1 = GetOuterRange_v1(arr, target, comp);
			int[] range2 = GetOuterRange_v2(arr, target, comp);

			//Console.WriteLine(string.Join(", ", range1[0], range1[1], range1[1] - range1[0]));

			if (
			    range1.Length != 2 ||
			    range2.Length != 2 ||
			    range1[0] != range2[0] ||
			    range1[1] != range2[1]
			    )
			    throw null;
		}
		Console.WriteLine("OK!");
	}

	// É\Å[ÉgçœÇ›ÇÃÉäÉXÉgì‡Ç≈äÓèÄílÇ…É}ÉbÉ`Ç∑ÇÈîÕàÕÇï‘Ç∑ÅB
	// list: ÉäÉXÉg
	// target: äÓèÄíl
	// comp: î‰ärÉÅÉ\ÉbÉh
	// ret: { äÓèÄílñ¢ñûÇÃç≈å„ÇÃà íu, äÓèÄílÇí¥Ç¶ÇÈç≈èâÇÃà íu }
	private static int[] GetOuterRange_v1<T>(IList<T> list, T target, Comparison<T> comp)
	{
		int l = -1;
		int r = list.Count;

		while (l + 1 < r)
		{
			int m = (l + r) / 2;
			int ret = comp(list[m], target);

			if (ret < 0)
			{
				l = m;
			}
			else if (ret > 0)
			{
				r = m;
			}
			else
			{
				l = GetBorder(list, v => comp(v, target) != 0, l, m);
				r = GetBorder(list, v => comp(v, target) == 0, m, r) + 1;
				break;
			}
		}
		return new int[] { l, r };
	}

	private static int GetBorder<T>(IList<T> list, Predicate<T> matchForLeft, int l, int r)
	{
		while (l + 1 < r)
		{
			int m = (l + r) / 2;

			if (matchForLeft(list[m]))
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}
		return l;
	}

	// ÉeÉXÉgóp
	private static int[] GetOuterRange_v2<T>(IList<T> list, T target, Comparison<T> comp)
	{
		int l;
		int r;

		for (l = list.Count - 1; 0 <= l; l--)
			if (comp(list[l], target) < 0)
				break;

		for (r = 0; r < list.Count; r++)
			if (comp(list[r], target) > 0)
				break;

		return new int[] { l, r };
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList()
	{
		int count = GetRandInt(200);
		int limit = GetRandInt(200) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	// Question:
	// https://twitter.com/potetoichiro/status/1576887286691639296

	public static void Main()
	{
		double RATE_DEGREE_RAD = Math.PI / 180.0;
		int angle = 0;

		D2Point pA = new D2Point(0.0, 0.0);
		D2Point pB = new D2Point(1.0, 0.0);
		D2Point pC = pB + AngleToPoint((angle += 180 - 140) * RATE_DEGREE_RAD, 1.0);
		D2Point pD = pC + AngleToPoint((angle += 180 - 110) * RATE_DEGREE_RAD, 1.0);
		D2Point pE = pD + AngleToPoint((angle +  180 - 130) * RATE_DEGREE_RAD, 1.0);
		D2Point pF = pA + AngleToPoint(100 * RATE_DEGREE_RAD, 1.0);

		double ed = GetAngle(pD - pE);
		double ef = GetAngle(pF - pE);

		double x = ed - ef;

		x /= RATE_DEGREE_RAD;

		Console.WriteLine($"x is {x} degrees.");
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}
	}

	public static D2Point AngleToPoint(double angle, double distance)
	{
		return new D2Point(
			distance * Math.Cos(angle),
			distance * Math.Sin(angle)
			);
	}

	public static double GetAngle(D2Point pt)
	{
		return GetAngle(pt.X, pt.Y);
	}

	public static double GetAngle(double x, double y)
	{
		if (y < 0.0) return Math.PI * 2.0 - GetAngle(x, -y);
		if (x < 0.0) return Math.PI - GetAngle(-x, y);

		if (x < y) return Math.PI / 2.0 - GetAngle(y, x);

		if (y == 0.0) return 0.0;
		if (y == x) return Math.PI / 4.0;

		double r1 = 0.0;
		double r2 = Math.PI / 4.0;
		double t = y / x;
		double rm;

		for (int c = 1; ; c++)
		{
			rm = (r1 + r2) / 2.0;

			if (50 < c)
				break;

			double rmt = Math.Tan(rm);

			if (t < rmt)
				r2 = rm;
			else
				r1 = rm;
		}
		return rm;
	}
}

----

public class Hello
{
	public static void Main()
	{ }
}

----
ó·ÇÃèúê·é‘ñ‚ëËÇìÒï™íTçıÇ≈âÇ≠ÅB

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	private const int MILLIS_PER_HOUR = 3600000;
	private const double SNOW_INIT = 1.0;
	private const double SNOWPLOW_POWER = 1.0;

	public static void Main()
	{
		double l = 0.0;
		double r = SNOW_INIT;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2;
			double rate = GetDistanceRate(m);

			if (1.5 < rate)
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}

		{
			double m = (l + r) / 2;
			double millis = SNOW_INIT / m;

			TimeSpan t = new TimeSpan(12, 0, 0);
			t -= TimeSpan.FromMilliseconds(millis);

			Console.WriteLine(t.ToString("hh\\:mm\\:ss\\.fff"));
		}
	}

	private static double GetDistanceRate(double snowPerMillis)
	{
		double snow = SNOW_INIT;
		double d = 0.0;

		for (int t = 0; t < MILLIS_PER_HOUR; t++)
		{
			d += SNOWPLOW_POWER / snow;
			snow += snowPerMillis;
		}
		double d1 = d;

		for (int t = 0; t < MILLIS_PER_HOUR; t++)
		{
			d += SNOWPLOW_POWER / snow;
			snow += snowPerMillis;
		}
		double d2 = d;

		return d2 / d1;
	}
}

----
ÉâÉìÉOÉåÅ[ÇÃñ‚ëË (êÆäpéläpå`) ÇâÇ≠ÅB

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	// ÉâÉìÉOÉåÅ[ÇÃñ‚ëË (êÆäpéläpå`) Wiki:
	// https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%BC%E3%81%AE%E5%95%8F%E9%A1%8C#%E6%95%B4%E8%A7%92%E5%9B%9B%E8%A7%92%E5%BD%A2

	public static void Main()
	{
		LangleyTetragonTest(20, 60, 50, 30);
		LangleyTetragonTest(20, 60, 40, 40);
	}

	private static void LangleyTetragonTest(double a, double b, double c, double d)
	{
		Console.WriteLine($"(a, b, c, d) == ({a:F9}, {b:F9}, {c:F9}, {d:F9}) ÇÃÇ∆Ç´ ...");

		// degree -> rad
		a *= Math.PI / 180.0;
		b *= Math.PI / 180.0;
		c *= Math.PI / 180.0;
		d *= Math.PI / 180.0;

		D2Point pB = new D2Point(0.0, 0.0);
		D2Point pC = new D2Point(1.0, 0.0);
		D2Point pA = GetCrossPoint(pB, pB + AngleToPoint((a + b), 1.0), pC, pC + AngleToPoint(Math.PI - c, 1.0));
		D2Point pD = GetCrossPoint(pB, pB + AngleToPoint(b, 1.0), pC, pC + AngleToPoint(Math.PI - (c + d), 1.0));

		double da = GetAngle(pA - pD);
		double db = GetAngle(pB - pD);

		double e = db - da;

		// rad -> degree
		e *= 180.0 / Math.PI;

		Console.WriteLine($"... e == {e:F9} Ç…Ç»ÇËÇ‹Ç∑ÅB");
	}

	// ïΩñ ç¿ïW
	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}
	}

	// p1-p2 Çí ÇÈíºê¸Ç∆ q1-q2 Çí ÇÈíºê¸ÇÃåì_Çï‘Ç∑ÅB
	private static D2Point GetCrossPoint(D2Point p1, D2Point p2, D2Point q1, D2Point q2)
	{
		double pxd = p2.X - p1.X;
		double qxd = q2.X - q1.X;
		double pyd = p2.Y - p1.Y;
		double qyd = q2.Y - q1.Y;

		double pn = p1.Y * p2.X - p1.X * p2.Y;
		double qn = q1.Y * q2.X - q1.X * q2.Y;

		double d = pyd * qxd - pxd * qyd;

		double x = (qn * pxd - pn * qxd) / d;
		double y = (qn * pyd - pn * qyd) / d;

		return new D2Point(x, y);
	}

	public static D2Point AngleToPoint(double angle, double distance)
	{
		return new D2Point(
			distance * Math.Cos(angle),
			distance * Math.Sin(angle)
			);
	}

	public static double GetAngle(D2Point pt)
	{
		return GetAngle(pt.X, pt.Y);
	}

	public static double GetAngle(double x, double y)
	{
		if (y < 0.0) return Math.PI * 2.0 - GetAngle(x, -y);
		if (x < 0.0) return Math.PI - GetAngle(-x, y);

		if (x < y) return Math.PI / 2.0 - GetAngle(y, x);
		//if (x < 1E-9) return 0.0; // ã…í[Ç…å¥ì_Ç…ãﬂÇ¢ç¿ïWÇÃèÍçáÅAèÌÇ… 0.0 Çï‘Ç∑ÅB

		if (y == 0.0) return 0.0;
		if (y == x) return Math.PI / 4.0;

		double r1 = 0.0;
		double r2 = Math.PI / 4.0;
		double t = y / x;
		double rm;

		for (int c = 1; ; c++)
		{
			rm = (r1 + r2) / 2.0;

			if (50 < c)
				break;

			double rmt = Math.Tan(rm);

			if (t < rmt)
				r2 = rm;
			else
				r1 = rm;
		}
		return rm;
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		double l = 0.0;
		double r = 1.0;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2;
			double rate = GetDistanceRate(m);

			if (1.5 < rate)
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}

		{
			double m = (l + r) / 2;
			double millis = 1.0 / m;

			TimeSpan t = new TimeSpan(12, 0, 0);
			t -= TimeSpan.FromMilliseconds(millis);

			Console.WriteLine(t.ToString("hh\\:mm\\:ss\\.fff"));
		}
	}

	private static double GetDistanceRate(double snowPerMillis)
	{
		double snow = 1.0;
		double d = 0.0;

		for (int t = 0; t < 3600000; t++)
		{
			d += 1.0 / snow;
			snow += snowPerMillis;
		}
		double d1 = d;

		for (int t = 0; t < 3600000; t++)
		{
			d += 1.0 / snow;
			snow += snowPerMillis;
		}
		double d2 = d;

		return d2 / d1;
	}
}

----

function* Endless(v) {
	for (; ; ) {
		yield v;
	}
}

function* Repeat(v, n) {
	for (var i = 0; i < n; i++) {
		yield v;
	}
}

function* Gaps(n) {
	yield n * (n - 1) - 1;
	yield* Endless(n - 1);
}

function* Sieve(gaps) {
	for (; ; ) {
		yield* Repeat(1, gaps());
		yield 0;
	}
}

function Supplier(e) {
	return () => e.next().value;
}

function Both(a, b) {
	return () => a() & b();
}

function* Primes(max) {
	var s = () => 1;

	for (var n = 2; n <= max; n++) {
		if (s()) {
			s = Both(s, Supplier(Sieve(Supplier(Gaps(n)))));
			yield n;
		}
	}
}

for (var n of Primes(100)) {
	console.log(n);
}

----

#include <stdio.h>
int main(void){
	char p[] = "12345678HelloWorld";
	*(char **)p = p;
	printf("%s\n", ******************************(char *******************************)p + 8);
}

----

#include <stdio.h>

int main()
{
	int n;

	for(n = 1; n <= 100; n++)
	{
		printf("%d\n\0Fizz\n\0______FizzBuzz\n" + (n % 3 + 1 >> 1 ^ 1 ^ ((n % 5 + 3 >> 2 ^ 1) * 5)) * 4, n);
	}
}

----

#include <stdio.h>

main()
{
	void *a[2];
	void ********************************************************************************************************************************
         ********************************************************************************************************************************p;
	void *q;

	p = (void *)a;

	a[0] = p;
	a[1] = p;

	q = *++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*p++;

	printf("%p\n%p\n%p\n%p\n%p\n", a + 1, a[0], a[1], p, q);
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			ulong a = GetULongRand();
			ulong b = GetULongRand();
			ulong ans1;
			ulong ans2;

			ans1 = Add64(a, b);
			unchecked { ans2 = a + b; }

			if (ans1 != ans2)
				throw null;

			ans1 = Sub64(a, b);
			unchecked { ans2 = a - b; }

			if (ans1 != ans2)
				throw null;

			ans1 = Mul64(a, b);
			unchecked { ans2 = a * b; }

			if (ans1 != ans2)
				throw null;

			b &= ChooseOne(
				ulong.MaxValue,
				0x0000ffffffffffffUL,
				0x00000000ffffffffUL,
				0x000000000000ffffUL
				);

			if (b == 0)
				b = 1;

			ans1 = Div64(a, b);
			ans2 = a / b;

			if (ans1 != ans2)
				throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static ulong Add64(ulong a, ulong b)
	{
		while (b != 0)
		{
			ulong na = a ^ b;
			b = (a & b) << 1;
			a = na;
		}
		return a;
	}

	private static ulong Sub64(ulong a, ulong b)
	{
		b ^= ulong.MaxValue;
		b = Add64(b, 1);
		return Add64(a, b);
	}

	private static ulong Mul64(ulong a, ulong b)
	{
		ulong c = 0;

		for (; b != 0; b >>= 1, a <<= 1)
			if ((b & 1) != 0)
				c = Add64(c, a);

		return c;
	}

	private static ulong Div64(ulong a, ulong b)
	{
		ulong c = 0;
		ulong d = 1;

		while ((b & (1UL << 63)) == 0)
		{
			b <<= 1;
			d <<= 1;
		}
		while (d != 0)
		{
			if (a >= b)
			{
				a = Sub64(a, b);
				c |= d;
			}
			b >>= 1;
			d >>= 1;
		}
		return c;
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static T ChooseOne<T>(params T[] values)
	{
		return values[(int)(GetULongRand() % (ulong)values.Length)];
	}

	// ====
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 30; testcnt++)
		{
			int[] arr1 = GetRandIntList().ToArray();
			int[] arr2 = arr1.ToArray(); // Cloning

			Array.Sort(arr1, (a, b) => a - b);

			CombSort(arr2, (a, b) => a - b);

			for (int index = 0; index < arr1.Length; index++)
				if (arr1[index] != arr2[index])
					throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static void CombSort<T>(IList<T> list, Comparison<T> comp)
	{
		for (int h = list.Count; ; ) // comb sort
		{
			h = (int)(h / 1.3);

			//if (h < 2) // ñ{óàÇÕÇ±ÇøÇÁ
			if (h < 7) // Ç±ÇÃÇ†ÇΩÇËÇ™ó«Ç¢ÇÁÇµÇ¢ÅB
				break;

			for (int index = h; index < list.Count; index++)
			{
				if (comp(list[index - h], list[index]) > 0) // ãtèáÇ©
				{
					// ì¸ÇÍë÷Ç¶
					T tmp = list[index - h];
					list[index - h] = list[index];
					list[index] = tmp;
				}
			}
		}
		for (int h = 1; h < list.Count; h++) // gnome sort
		{
			for (int index = h; 0 < index; index--)
			{
				if (comp(list[index - 1], list[index]) > 0) // ãtèáÇ©
				{
					// ì¸ÇÍë÷Ç¶
					T tmp = list[index - 1];
					list[index - 1] = list[index];
					list[index] = tmp;
				}
				else // ê≥èáÇ©
				{
					break;
				}
			}
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList()
	{
		int count = GetRandInt(10000);
		int limit = GetRandInt(10000) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----

main(){}

----

main(){}

----

function* Fibonacci() {
	var a = 1;
	var b = 0;

	for (; ; ) {
		yield a += b;
		yield b += a;
	}
}

var g = Fibonacci();

for (var c = 0; c < 50; c++) {
	console.log(g.next().value);
}

----

console.log(1 + 2);

----

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define N 3
#define EXP_MAX 1000
#define BLOCKSZ 10
#define VALSZ 10000000000000000000ul

typedef unsigned long uint64;
typedef unsigned __int128 uint128;

typedef struct B_st {
	uint64 Vals[BLOCKSZ];
	struct B_st *Prev;
	struct B_st *Next;
}
B_t;

static B_t Top;
static B_t *Last;

static void MulN(uint64 n) {
	B_t *b = &Top;
	B_t *bn;
	int index;
	uint128 v = 0;

	for(; ; ) {
		for(index = 0; index < BLOCKSZ; index++) {
			v += (uint128)b->Vals[index] * n;
			b->Vals[index] = (uint64)(v % VALSZ);
			v /= VALSZ;
		}
		bn = b->Next;

		if(!bn) {
			if(!v) {
				break;
			}
			bn = (B_t *)calloc(1, sizeof(B_t));

			if(!bn)
				exit(1);

			b->Next = bn;
			bn->Prev = b;
			Last = bn;
		}
		b = bn;
	}
}

static void DoPrint(uint64 n, uint64 exp) {
	B_t *b = Last;
	int index;

	printf("%lu^%lu=", n, exp);

	for(index = BLOCKSZ - 1; !b->Vals[index]; index--);

	printf("%lu", b->Vals[index]);

	while(0 <= --index) {
		printf("%019lu", b->Vals[index]);
	}
	while(b = b->Prev) {
		for(index = BLOCKSZ - 1; 0 <= index; index--) {
			printf("%019lu", b->Vals[index]);
		}
	}
	printf("\n");
}

int main(void) {
	uint64 exp;

	Top.Vals[0] = 1;
	Last = &Top;

	DoPrint(N, 0);

	for(exp = 1; exp <= EXP_MAX; exp++) {
		MulN(N);
		DoPrint(N, exp);
	}
}
