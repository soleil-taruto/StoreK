----
Make10

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		MakeTen(1, 1, 5, 8);
		MakeTen(4, 4, 6, 6);
		MakeTen(3, 4, 7, 8);
		MakeTen(5, 6, 7, 8);
	}

	private class Operand
	{
		public int Numer;
		public int Denom;
		public string Str;

		public bool IsInt()
		{
			return this.Numer % this.Denom == 0;
		}

		public int GetIntValue()
		{
			return this.Numer / this.Denom;
		}
	}

	private static void MakeTen(params int[] ns)
	{
		Console.WriteLine(string.Join(", ", ns) + " ==>");
		OpStrs = new List<string>();
		MakeTen(ns.Select(v => new Operand() { Numer = v, Denom = 1, Str = "" + v }).ToArray());

		foreach (string str in OpStrs.Distinct())
			Console.WriteLine("\t" + str + " = 10");

		OpStrs = null;
		Console.WriteLine("");
	}

	private static List<string> OpStrs;

	private static void MakeTen(Operand[] os)
	{
		if (os.Length == 1)
		{
			Operand o = os[0];

			if (
				o.IsInt() &&
				o.GetIntValue() == 10
				)
				OpStrs.Add(o.Str);

			return;
		}

		for (int a = 0; a < os.Length; a++)
		for (int b = 0; b < os.Length; b++)
		{
			if (a == b)
				continue;

			Operand[] next = os.ToArray();
			next[a] = null;
			next[b] = null;
			next = next.Where(v => v != null).Concat(new Operand[] { null }).ToArray();
			int x = next.Length - 1;

			next[x] = new Operand()
			{
				Numer = os[a].Numer * os[b].Denom + os[b].Numer * os[a].Denom,
				Denom = os[a].Denom * os[b].Denom,
				Str = "(" + os[a].Str + " + " + os[b].Str + ")",
			};

			MakeTen(next);

			next[x] = new Operand()
			{
				Numer = os[a].Numer * os[b].Denom - os[b].Numer * os[a].Denom,
				Denom = os[a].Denom * os[b].Denom,
				Str = "(" + os[a].Str + " - " + os[b].Str + ")",
			};

			MakeTen(next);

			next[x] = new Operand()
			{
				Numer = os[a].Numer * os[b].Numer,
				Denom = os[a].Denom * os[b].Denom,
				Str = "(" + os[a].Str + " * " + os[b].Str + ")",
			};

			MakeTen(next);

			if (os[b].Numer != 0)
			{
				next[x] = new Operand()
				{
					Numer = os[a].Numer * os[b].Denom,
					Denom = os[a].Denom * os[b].Numer,
					Str = "(" + os[a].Str + " / " + os[b].Str + ")",
				};

				MakeTen(next);
			}
		}
	}
}

----
MergeSort

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			var arr = GetRandIntList(60)
				.ToArray().Skip(0); // リストを確定する。

			Console.WriteLine("Before: " + string.Join(", ", arr));

			arr = MergeSort(arr, (a, b) => a - b);

			Console.WriteLine("After : " + string.Join(", ", arr));
		}
	}

	private static IEnumerable<T> MergeSort<T>(IEnumerable<T> list, Comparison<T> comp)
	{
		Queue<IEnumerable<T>> q = new Queue<IEnumerable<T>>(list.Select(v => new T[] { v }));

		if (q.Count == 0)
			return new T[0];

		while (2 <= q.Count)
			q.Enqueue(E_Merge(q.Dequeue(), q.Dequeue(), comp));

		return q.Dequeue();
	}

	private static IEnumerable<T> E_Merge<T>(IEnumerable<T> v1, IEnumerable<T> v2, Comparison<T> comp)
	{
		IEnumerator<T> a = v1.GetEnumerator();
		IEnumerator<T> b = v2.GetEnumerator();

		if (!a.MoveNext()) throw null;
		if (!b.MoveNext()) throw null;

		for (; ; )
		{
			int ret = comp(a.Current, b.Current);

			if (ret <= 0)
			{
				yield return a.Current;
				if (!a.MoveNext()) { a = b; break; }
			}
			if (0 <= ret)
			{
				yield return b.Current;
				if (!b.MoveNext()) break;
			}
		}
		do { yield return a.Current; } while (a.MoveNext());
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList(int scale)
	{
		int count = GetRandInt(scale);
		int limit = GetRandInt(scale) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----
MergeSort 確認用

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 30; testcnt++)
		{
			int[] arr1 = GetRandIntList(10000).ToArray();
			int[] arr2 = arr1.ToArray(); // Cloning

			Array.Sort(arr1, (a, b) => a - b);

			arr2 = MergeSort(arr2, (a, b) => a - b).ToArray();

			for (int index = 0; index < arr1.Length; index++)
				if (arr1[index] != arr2[index])
					throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static IEnumerable<T> MergeSort<T>(IEnumerable<T> list, Comparison<T> comp)
	{
		Queue<IEnumerable<T>> q = new Queue<IEnumerable<T>>(list.Select(v => new T[] { v }));

		if (q.Count == 0)
			return new T[0];

		while (2 <= q.Count)
			q.Enqueue(E_Merge(q.Dequeue(), q.Dequeue(), comp));

		return q.Dequeue();
	}

	private static IEnumerable<T> E_Merge<T>(IEnumerable<T> v1, IEnumerable<T> v2, Comparison<T> comp)
	{
		IEnumerator<T> a = v1.GetEnumerator();
		IEnumerator<T> b = v2.GetEnumerator();

		if (!a.MoveNext()) throw null;
		if (!b.MoveNext()) throw null;

		for (; ; )
		{
			int ret = comp(a.Current, b.Current);

			if (ret <= 0)
			{
				yield return a.Current;
				if (!a.MoveNext()) { a = b; break; }
			}
			if (0 <= ret)
			{
				yield return b.Current;
				if (!b.MoveNext()) break;
			}
		}
		do { yield return a.Current; } while (a.MoveNext());
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList(int scale)
	{
		int count = GetRandInt(scale);
		int limit = GetRandInt(scale) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----
Brainfuck Interpreter

#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint; // 32-bit uint

#define errorCase(status) \
	{ if ((status)) { printf("ERROR %d\n", __LINE__); exit(1); }}

#define MEMORY_SIZE 1000000

static uint Memory[MEMORY_SIZE];
static uint Ptr;

static uint Increment_Ptr(void)
{
	Ptr++;
	errorCase(Ptr == MEMORY_SIZE);
	return 0;
}
static uint Decrement_Ptr(void)
{
	errorCase(!Ptr);
	Ptr--;
	return 0;
}
static uint Increment(void)
{
	errorCase(Memory[Ptr] == ~(uint)0);
	Memory[Ptr]++;
	return 0;
}
static uint Decrement(void)
{
	errorCase(!Memory[Ptr]);
	Memory[Ptr]--;
	return 0;
}
static uint PrintChar(void)
{
	uint chr = Memory[Ptr];

	if (chr == 0x09) // ? Tab
	{
		printf("\t");
	}
	else if (chr == 0x0d) // ? CR
	{
	    // ignore CR
	}
	else if (chr == 0x0a) // ? LF
	{
		printf("\n");
	}
	else if (0x20 <= chr && chr <= 0x7e) // ? ASCII
	{
		printf("%c", (int)chr);
	}
	else
	{
		printf("[%02x]\n", chr);
	}
	return 0;
}
static uint InputChar(void)
{
	int chr = fgetc(stdin);

	if (0x00 <= chr && chr <= 0xff)
	{
		Memory[Ptr] = (uint)chr;
	}
	else
	{
		printf("INPUT ERROR\n");
	}
	return 0;
}
static uint EnterLoop(void)
{
	return Memory[Ptr] ? 1 : 0;
}
static uint End(void)
{
	exit(0);
	return 0; // dummy
}

typedef struct Command_st
{
	uint (*Method)(void);
	struct Command_st *Next[2];
	struct Command_st *StackNext;
}
Command_t;

static Command_t *MakeCommand(Command_t *p, uint (*method)(void))
{
	Command_t *i = malloc(sizeof(Command_t));

	errorCase(!i);

	i->Method = method;
	i->Next[0] = NULL;
	i->Next[1] = NULL;

	p->Next[0] = i;

	return i;
}
static Command_t *LoadProgram(char *source)
{
	Command_t *stack = NULL;
	Command_t *command;
	Command_t entry;

	command = &entry;

	for (char *p = source; *p; p++)
	{
		switch(*p)
		{
		case '>': command = MakeCommand(command, Increment_Ptr); break;
		case '<': command = MakeCommand(command, Decrement_Ptr); break;
		case '+': command = MakeCommand(command, Increment); break;
		case '-': command = MakeCommand(command, Decrement); break;
		case '.': command = MakeCommand(command, PrintChar); break;
		case ',': command = MakeCommand(command, InputChar); break;
		case '[':
			command = MakeCommand(command, EnterLoop);
			command->StackNext = stack;
			stack = command;
			break;

		case ']':
		    errorCase(!stack);
			command->Next[0] = stack;
			stack = stack->StackNext;
			command = command->Next[0];
			command->Next[1] = command->Next[0];
			break;

		default:
			break;
		}
	}
	MakeCommand(command, End);
	return entry.Next[0];
}
static void ExecuteProgram(char *source)
{
	Command_t *i = LoadProgram(source); // HACK: free

	//memset(Memory, 0x00, sizeof(Memory));
	//Ptr = 0;

	for (; ; )
	{
		i = i->Next[i->Method()];
	}
}

// ====
// ====
// ====

int main(int argc, char **argv)
{
	ExecuteProgram("++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.");
}

----

#include <stdio.h>
#include <time.h>

#define SEC_DIV 2

static long TryGetIncrementPerSec(void)
{
	static long checkPeriod = 1;
	long c;
	long stClock = clock();

	for (c = 0; c % checkPeriod || clock() - stClock < CLOCKS_PER_SEC / SEC_DIV; c++);

	checkPeriod = c / 100;

	return c * SEC_DIV;
}

int main(void)
{
	TryGetIncrementPerSec();
	TryGetIncrementPerSec();

	printf("This environment is capable of increment %lld times per second in simple loop.\n", TryGetIncrementPerSec());
}

----
1以上65535以下の整数においてそれを初期値としたコラッツ数列が最初に1に達するまでに「割る2」を行う回数が唯一のもの

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	//private const int N_MAX = 255;
	private const int N_MAX = 65535;
	//private const int N_MAX = 16777215;

	public static void Main()
	{
		Dictionary<int, int> dc2n = new Dictionary<int, int>();
		Dictionary<int, int> n2dc = new Dictionary<int, int>();

		for (int n = 1; n <= N_MAX; n++)
		{
			int dc = GetCollatzDivideCount(n);

			if (dc2n.ContainsKey(dc))
				dc2n[dc] = -1;
			else
				dc2n[dc] = n;
		}
		foreach (int dc in dc2n.Keys)
		{
			int n = dc2n[dc];

			if (n != -1)
				n2dc[n] = dc;
		}

		Console.WriteLine(string.Format("1 以上 {0} 以下の整数において、それを初期値としたコラッツ数列が最初に 1 に達するまでに「割る2」を行う回数が唯一のもの：", N_MAX));

		foreach (int n in n2dc.Keys.OrderBy(v => v))
			Console.WriteLine(string.Format("初期値 {0} のとき割る2を {1} 回行う。割る2を行う回数が {2} 回となる初期値は {3} 以外に(この範囲には)ない。", n, n2dc[n], n2dc[n], n));
	}

	private static int GetCollatzDivideCount(long n)
	{
		int dc = 0;

		while (n != 1)
		{
			if (n % 2 == 0)
			{
				n /= 2;
				dc++;
			}
			else
			{
				if ((long.MaxValue - 1) / 3 < n)
					throw new OverflowException();

				n *= 3;
				n++;
			}
		}
		return dc;
	}
}

----
PrimeVoid_k (2)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

// ====
// Eratosthenes
// ====

//	#define N 1875000000 // 3.0E+10 / 16
//	#define N 187500000 // 3.0E+9 / 16
//	#define N 18750000 // 3.0E+8 / 16
//	#define N 6250000 // 1.0E+8 / 16
	#define N 6250001 // (1.0E+8 + 16) / 16

#define N_P13 15015

void GetPrimes(int *p)
{
	unsigned char *t = (unsigned char *)malloc(N); // 8-bit uint array
	unsigned long c; // 64-bit uint
	unsigned long d; // 64-bit uint
	unsigned int i; // 32-bit uint

	if(!t)
		exit(1); // fatal

	memset(t, 0x00, N_P13);

//	printf("2\n");
	*p++ = 2;

	for (c = 3; c <= 13; c += 2)
	{
		if (c != 9)
		{
//			printf("%llu\n", c);
			*p++ = (int)c;

			for (d = c; d / 16 < N_P13; d += c * 2)
			{
				t[d / 16] |= 1 << d / 2 % 8;
			}
		}
	}
	for (i = N_P13; i + N_P13 <= N; i += N_P13)
	{
		memcpy(t + i, t, N_P13);
	}
	for (; i < N; i++)
	{
		t[i] = t[i - N_P13];
	}
	for (c = 17; c / 16 < N; c += 2)
	{
		if (!(t[c / 16] & (1 << c / 2 % 8)))
		{
//			printf("%llu\n", c);
			*p++ = (int)c;

			if (c < 0x100000000) // If c < 2^32
			{
				for(d = c * c; d / 16 < N; d += c * 2)
				{
					t[d / 16] |= 1 << d / 2 % 8;
				}
			}
		}
	}
	free(t);

	*p = 0; // put ender
}

// ====

static void PrintPrimeVoid(int *primes, int primeCount, int k)
{
	printf("2 以上 %d 以下の異なる 2 つの素数についてその間にある素数の個数が %d 未満のもののうち差が最大となるものは：\n", primes[primeCount - 1], k);

	int maxDiff = 0;

	for (int c = 0; c + k < primeCount; c++)
		if (maxDiff < primes[c + k] - primes[c])
			maxDiff = primes[c + k] - primes[c];

	for (int c = 0; c + k < primeCount; c++)
		if (maxDiff == primes[c + k] - primes[c])
			printf("%d と %d その差は %d\n", primes[c], primes[c + k], primes[c + k] - primes[c]);

	printf("\n");
}

int main()
{
	int *primes = (int *)malloc(10000000 * sizeof(int)); // HACK: rough size
	int primeCount;
	int c;

	if (!primes)
		exit(1); // fatal

	GetPrimes(primes);
	for (c = 0; primes[c]; c++);
	primeCount = c;

	for (int k = 1; k <= 100; k++)
	{
		PrintPrimeVoid(primes, primeCount, k);
	}
}

----
PrimeVoid_k

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	//private const int RANGE_SCALE = 10000;
	//private const int RANGE_SCALE = 100000;
	//private const int RANGE_SCALE = 1000000;
	private const int RANGE_SCALE = 3000000;
	//private const int RANGE_SCALE = 10000000;
	//private const int RANGE_SCALE = 100000000;
	//private const int RANGE_SCALE = 1000000000;

	private static int[] Primes =
		Enumerable.Range(0, RANGE_SCALE).Where(n => IsPrime((ulong)n))
		.Concat(new int[] {
		Enumerable.Range(RANGE_SCALE, int.MaxValue - RANGE_SCALE).First(n => IsPrime((ulong)n)) })
		.ToArray();

	public static void Main()
	{
		for (int k = 1; k <= 100; k++)
			PrintPrimeVoid(k);
	}

	private static void PrintPrimeVoid(int k)
	{
		Console.WriteLine($"2 以上 {Primes[Primes.Length - 1]} 以下の異なる 2 つの素数についてその間にある素数の個数が {k} 未満のもののうち差が最大となるものは：");

		int maxDiff = Enumerable.Range(0, Primes.Length - k).Select(i => Primes[i + k] - Primes[i]).Max();

		foreach (int i in Enumerable.Range(0, Primes.Length - k))
			if (maxDiff == Primes[i + k] - Primes[i])
				Console.WriteLine($"{Primes[i]} と {Primes[i + k]} その差は {Primes[i + k] - Primes[i]}");

		Console.WriteLine("");
	}

	// ====
	// MillerRabin
	// ====

	public static bool IsPrime(ulong n)
	{
		if (n <= 61)
			return new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61 }.Contains((uint)n);

		if (n % 2 == 0)
			return false;

		ulong d = n;
		int r;
		for (r = 0; ((d >>= 1) & 1) == 0; r++) ;

		// memo:
		// -- https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test
		// if n < 4,759,123,141, it is enough to test a = 2, 7, and 61;
		// if n < 18,446,744,073,709,551,616 = 2^64, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.

		if (n <= uint.MaxValue)
			return !new uint[] { 2, 7, 61 }
				.Any(x => !MillerRabinTest32(x, (uint)d, r, (uint)n));
		else
			return !new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37 }
				.Any(x => !MillerRabinTest64((ulong)x, d, r, n));
	}

	private static bool MillerRabinTest32(uint x, uint d, int r, uint n)
	{
		x = ModPow32(x, d, n);

		if (x != 1 && x != n - 1)
		{
			for (int s = r; ; s--)
			{
				if (s <= 0)
					return false;

				x = (uint)(((ulong)x * x) % n);

				if (x == n - 1)
					break;
			}
		}
		return true;
	}

	private static uint ModPow32(uint b, uint e, uint m)
	{
		uint a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = (uint)(((ulong)a * b) % m);

			b = (uint)(((ulong)b * b) % m);
		}
		return a;
	}

	private static bool MillerRabinTest64(ulong x, ulong d, int r, ulong n)
	{
		x = ModPow64(x, d, n);

		if (x != 1 && x != n - 1)
		{
			for (int c = r; ; c--)
			{
				if (c <= 0)
					return false;

				x = ModPow64(x, 2, n);

				if (x == n - 1)
					break;
			}
		}
		return true;
	}

	private static ulong ModPow64(ulong b, ulong e, ulong m)
	{
		ulong a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModMul64(a, b, m);

			b = ModMul64(b, b, m);
		}
		return a;
	}

	private static ulong ModMul64(ulong b, ulong e, ulong m)
	{
		ulong a = 0;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModAdd64(a, b, m);

			b = ModAdd64(b, b, m);
		}
		return a;
	}

	private static ulong ModAdd64(ulong a, ulong b, ulong m)
	{
		ulong r = (ulong.MaxValue % m + 1) % m;

		while (ulong.MaxValue - a < b)
		{
			unchecked { a += b; }
			b = r;
		}
		return (a + b) % m;
	}

	// =====
}

----
Xorshift-64 コピペ用

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		RndCtr = (ulong)DateTime.Now.Ticks;

		for (int c = 0; c < 100; c++)
		{
			Console.WriteLine(GetRandULong());
		}
	}

	// ====
	// Random
	// ====

	public static ulong RndCtr = 1;

	public static ulong GetRandULong()
	{
		RndCtr ^= RndCtr << 13;
		RndCtr ^= RndCtr >> 7;
		RndCtr ^= RndCtr << 17;
		return RndCtr;
	}

	// ====
}

----
Sin Cos from 0 to 90 degree Part2

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		D2Point[] Points = Enumerable.Range(0, 91).Select(dummy => new D2Point(0.0, 1.0)).ToArray();

		Points[0].X = 1.0;
		Points[0].Y = 0.0;

		for (int c = 0; c < 24000; c++)
		{
			for (int d = 1; d <= 89; d++)
			{
				Points[d] = (Points[d - 1] + Points[d + 1]) / 2.0;
				Points[d] /= GetDistance(Points[d]);
			}
		}

		for (int d = 0; d <= 90; d++)
		{
			Console.WriteLine($"Cos {d} degree is {Points[d].X:F12}");
			Console.WriteLine($"Sin {d} degree is {Points[d].Y:F12}");
		}
	}

	private static double GetDistance(D2Point pt)
	{
		return Math.Sqrt(pt.X * pt.X + pt.Y * pt.Y);
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----
IntSqrt UIntSqrt

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(uint.MaxValue - 3, (ulong)(uint.MaxValue - 3) * (uint.MaxValue - 3), (ulong)(uint.MaxValue - 2) * (uint.MaxValue - 2) - 1);
		Test01_a(uint.MaxValue - 2, (ulong)(uint.MaxValue - 2) * (uint.MaxValue - 2), (ulong)(uint.MaxValue - 1) * (uint.MaxValue - 1) - 1);
		Test01_a(uint.MaxValue - 1, (ulong)(uint.MaxValue - 1) * (uint.MaxValue - 1), (ulong)(uint.MaxValue - 0) * (uint.MaxValue - 0) - 1);
		Test01_a(uint.MaxValue - 0, (ulong)(uint.MaxValue - 0) * (uint.MaxValue - 0), ulong.MaxValue);

		Test01_b(10000, 100);
		Test01_b(10000, 10000);
		Test01_b(10000, 1000000);
		Test01_b(10000, 100000000);
		Test01_b(10000, 10000000000);
		Test01_b(10000, 1000000000000);
		Test01_b(10000, 100000000000000);
		Test01_b(10000, 10000000000000000);
		Test01_b(10000, 1000000000000000000);
		Test01_b(10000, 18440000000000000000);

		Test01_c(int.MaxValue - 3, (long)(int.MaxValue - 3) * (int.MaxValue - 3), (long)(int.MaxValue - 2) * (int.MaxValue - 2) - 1);
		Test01_c(int.MaxValue - 2, (long)(int.MaxValue - 2) * (int.MaxValue - 2), (long)(int.MaxValue - 1) * (int.MaxValue - 1) - 1);
		Test01_c(int.MaxValue - 1, (long)(int.MaxValue - 1) * (int.MaxValue - 1), (long)(int.MaxValue - 0) * (int.MaxValue - 0) - 1);
		Test01_c(int.MaxValue - 0, (long)(int.MaxValue - 0) * (int.MaxValue - 0), ((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) - 1);

		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 0));
		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 1));
		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 2));
		ToThrowPrint(() => IntSqrt(((long)int.MaxValue + 1) * ((long)int.MaxValue + 1) + 3));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 0));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 1));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 2));
		ToThrowPrint(() => IntSqrt(long.MaxValue - 3));

		Test01_d(10000, 100);
		Test01_d(10000, 10000);
		Test01_d(10000, 1000000);
		Test01_d(10000, 100000000);
		Test01_d(10000, 10000000000);
		Test01_d(10000, 1000000000000);
		Test01_d(10000, 100000000000000);
		Test01_d(10000, 10000000000000000);
		Test01_d(10000, 1000000000000000000);
		Test01_d(10000, 4610000000000000000);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(uint expectRet, ulong minPrm, ulong maxPrm)
	{
		for (ulong prm = minPrm; ; prm++)
		{
			uint ret = UIntSqrt(prm);

			if (ret != expectRet)
				throw null; // BUG !!!

			// ----

			if (maxPrm <= prm)
				break;

			if (minPrm + 3000 < maxPrm) // 多い -> 中スキップ
				if (minPrm + 1000 < prm && prm < maxPrm - 1000)
					prm += (maxPrm - prm) / 2;
		}
		Console.WriteLine("OK");
	}

	private static void Test01_b(int testCount, ulong prmScale)
	{
		for (int testcnt = 0; testcnt < testCount; testcnt++)
		{
			ulong prm = GetULongRand() % prmScale;
			uint ret = UIntSqrt(prm);

			if ((ulong)ret * ret > prm)
				throw null; // BUG !!!

			if ((ulong)(ret + 1) * (ret + 1) <= prm)
				throw null; // BUG !!!
		}
		Console.WriteLine("OK");
	}

	private static void Test01_c(int expectRet, long minPrm, long maxPrm)
	{
		for (long prm = minPrm; ; prm++)
		{
			int ret = IntSqrt(prm);

			if (ret != expectRet)
				throw null; // BUG !!!

			// ----

			if (maxPrm <= prm)
				break;

			if (minPrm + 3000 < maxPrm) // 多い -> 中スキップ
				if (minPrm + 1000 < prm && prm < maxPrm - 1000)
					prm += (maxPrm - prm) / 2;
		}
		Console.WriteLine("OK");
	}

	private static void Test01_d(int testCount, long prmScale)
	{
		for (int testcnt = 0; testcnt < testCount; testcnt++)
		{
			long prm = (long)(GetULongRand() % (ulong)prmScale);
			int ret = IntSqrt(prm);

			if ((long)ret * ret > prm)
				throw null; // BUG !!!

			if ((long)(ret + 1) * (ret + 1) <= prm)
				throw null; // BUG !!!
		}
		Console.WriteLine("OK");
	}

	// ----

	public static Exception ToThrow(Action routine)
	{
		try
		{
			routine();
		}
		catch (Exception ex)
		{
			return ex;
		}
		throw new Exception("例外を投げませんでした。");
	}

	public static void ToThrowPrint(Action routine)
	{
		Console.WriteLine("想定された例外：" + ToThrow(routine).Message);
	}

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	// ====
	// ====
	// ====

	public static int IntSqrt(long value)
	{
		if (value < 0 || (1L << 62) <= value)
			throw new ArgumentException();

		return (int)UIntSqrt((ulong)value);
	}

#if true
		public static uint UIntSqrt(ulong value)
		{
			uint ret = 0;

			for (uint bit = 1u << 31; bit != 0; bit >>= 1)
			{
				uint m = ret | bit;

				if ((ulong)m * m <= value)
					ret = m;
			}
			return ret;
		}
#else
	public static uint UIntSqrt(ulong value)
	{
		ulong l = 0;
		ulong r = (ulong)uint.MaxValue + 1;

		while (l + 1 < r)
		{
			ulong m = (l + r) / 2;

			if (m * m <= value)
				l = m;
			else
				r = m;
		}
		return (uint)l;
	}
#endif
}

----
Sin Cos from 0 to 90 degree (Queue)

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		Queue<AngleInfo> angles = new Queue<AngleInfo>(new AngleInfo[]
		{
			new AngleInfo() { Degree =  0.0, Point = new D2Point(1.0, 0.0) },
			new AngleInfo() { Degree = 90.0, Point = new D2Point(0.0, 1.0) },
			null, // ender
		});

		Subdivide(angles, 10);

		foreach (AngleInfo angle in angles)
		{
			Console.WriteLine($"Cos {angle.Degree:F9} degree is {angle.Point.X:F15}");
			Console.WriteLine($"Sin {angle.Degree:F9} degree is {angle.Point.Y:F15}");
		}
	}

	private static void Subdivide(Queue<AngleInfo> angles, int depth)
	{
		AngleInfo last = angles.Dequeue();

		for (; ; )
		{
			AngleInfo next = angles.Dequeue();

			if (next == null) // is ender
			{
				angles.Enqueue(last);

				if (--depth <= 0)
					break;

				angles.Enqueue(null); // put ender
				last = angles.Dequeue();
				continue;
			}

			double mDeg = (last.Degree + next.Degree) / 2.0;
			D2Point mPt = (last.Point + next.Point) / 2.0;
			double d = M_Sqrt(mPt.X * mPt.X + mPt.Y * mPt.Y);
			mPt /= d;

			angles.Enqueue(last);
			angles.Enqueue(new AngleInfo() { Degree = mDeg, Point = mPt });

			last = next;
		}
	}

	/*
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv <= value)
				l = m;
			else
				r = m;
		}
		return l;
	}
	/*/
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv < value)
				l = m;
			else
				r = m;
		}

		{
			double m = (l + r) / 2.0;

			return m;
		}
	}
	//*/

	private class AngleInfo
	{
		public double Degree;
		public D2Point Point;
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----

public class Hello
{
	public static void Main()
	{ }
}

----
Sin Cos from 0 to 90 degree

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		IEnumerable<AngleInfo> angles = new AngleInfo[]
		{
			new AngleInfo() { Degree =  0.0, Point = new D2Point(1.0, 0.0) },
			new AngleInfo() { Degree = 90.0, Point = new D2Point(0.0, 1.0) },
		};

		for (int c = 0; c < 10; c++)
			angles = Subdivide(angles);

		foreach (AngleInfo angle in angles)
		{
			Console.WriteLine($"Cos {angle.Degree:F9} degree is {angle.Point.X:F15}");
			Console.WriteLine($"Sin {angle.Degree:F9} degree is {angle.Point.Y:F15}");
		}
	}

	private static IEnumerable<AngleInfo> Subdivide(IEnumerable<AngleInfo> angles)
	{
		IEnumerator<AngleInfo> reader = angles.GetEnumerator();

		if (!reader.MoveNext())
			throw new Exception("angles is empty");

		AngleInfo last = reader.Current;

		while (reader.MoveNext())
		{
			AngleInfo next = reader.Current;

			double mDeg = (last.Degree + next.Degree) / 2.0;
			D2Point mPt = (last.Point + next.Point) / 2.0;
			double d = M_Sqrt(mPt.X * mPt.X + mPt.Y * mPt.Y);
			mPt /= d;

			yield return last;
			yield return new AngleInfo() { Degree = mDeg, Point = mPt };

			last = next;
		}
		yield return last;
	}

	/*
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv <= value)
				l = m;
			else
				r = m;
		}
		return l;
	}
	/*/
	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = value < 1.0 ? 1.0 : value;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv < value)
				l = m;
			else
				r = m;
		}

		{
			double m = (l + r) / 2.0;

			return m;
		}
	}
	//*/

	private class AngleInfo
	{
		public double Degree;
		public D2Point Point;
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		Test01();
		//Test02();
	}

	private static void Test01()
	{
		for (double degree = 0.0; degree < 360.0; degree += 1.0)
		//for (double degree = 0.0; degree < 360.0; degree += 0.1)
		{
			double rad = degree * Math.PI / 180.0;

			double s1 = Sin(degree);
			double s2 = Math.Sin(rad);

			double c1 = Cos(degree);
			double c2 = Math.Cos(rad);

			double t1 = Tan(degree);
			double t2 = Math.Tan(rad);

			Console.WriteLine(string.Format("{0:F1} 度のときの誤差 ==> Sin : {1:F20} , Cos : {2:F20} , Tan : {3:F20}"
				, degree
				, Math.Abs(s1 - s2)
				, Math.Abs(c1 - c2)
				, Math.Abs(t1 - t2)
				));
		}
	}

	private static void Test02()
	{
		for (double value = 0.0; value < 10.0; value += 0.10)
		//for (double value = 0.0; value < 10.0; value += 0.01)
		{
			double r1 = M_Sqrt(value);
			double r2 = Math.Sqrt(value);

			Console.WriteLine(string.Format("{0:F2} の平方根の誤差 ==> {1:F20}"
				, value
				, Math.Abs(r1 - r2)
				));
		}
	}

	// ----
	// ----
	// ----

	public static double Tan(double degree)
	{
		return Sin(degree) / Cos(degree);
	}

	public static double Sin(double degree)
	{
		return Cos(degree - 90.0);
	}

	public static double Cos(double degree)
	{
		while (degree < 0.0)
			degree += 360.0;

		while (360.0 < degree)
			degree -= 360.0;

		return M_Cos(degree);
	}

	private static double M_Cos(double degree)
	{
		if (180.0 < degree)
			return M_Cos(360.0 - degree);

		if (90.0 < degree)
			return M_Cos(180.0 - degree) * -1.0;

		D2Point lPt = new D2Point(1.0, 0.0);
		D2Point rPt = new D2Point(0.0, 1.0);
		double lDeg = 0.0;
		double rDeg = 90.0;

		for (int c = 0; c < 50; c++)
		{
			D2Point mPt = (lPt + rPt) / 2.0;
			double d = M_Sqrt(mPt.X * mPt.X + mPt.Y * mPt.Y);
			mPt /= d;
			double mDeg = (lDeg + rDeg) / 2.0;

			if (mDeg < degree)
			{
				lPt = mPt;
				lDeg = mDeg;
			}
			else
			{
				rPt = mPt;
				rDeg = mDeg;
			}
		}

		{
			D2Point mPt = (lPt + rPt) / 2.0;

			return mPt.X;
		}
	}

	private static double M_Sqrt(double value)
	{
		if (value < 0.0)
			throw new ArgumentException();

		double l = 0.0;
		double r = Math.Max(1.0, value);

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2.0;
			double mv = m * m;

			if (mv < value)
				l = m;
			else
				r = m;
		}

		{
			double m = (l + r) / 2.0;

			return m;
		}
	}

	// ====

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}

		public static D2Point operator *(D2Point a, double b)
		{
			return new D2Point(a.X * b, a.Y * b);
		}

		public static D2Point operator /(D2Point a, double b)
		{
			return new D2Point(a.X / b, a.Y / b);
		}
	}
}

----
IEqualityComparer<int[]> を実装する。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(2);
		Test01_a(3);
		Test01_a(5);
		Test01_a(7);
		Test01_a(11);
		Test01_a(13);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(int valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<int[]> hs2 = new HashSet<int[]>(new IntsIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			int[] value = GetRandIntList(GetRandInt(valueScale));
			string strValue = ToString(value);

			bool c1 = hs1.Contains(strValue);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(strValue);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(strValue);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	// Int配列 -> 文字列
	private static string ToString(int[] arr)
	{
		return string.Join("_", arr);
	}

	public class IntsIEC : IEqualityComparer<int[]>
	{
		public bool Equals(int[] a, int[] b)
		{
			if (a.Length != b.Length)
				return false;

			for (int index = 0; index < a.Length; index++)
				if (a[index] != b[index])
					return false;

			return true;
		}

		public int GetHashCode(int[] a)
		{
		    // HACK: HachCode.Combine にこういう使い方が想定されているのか疑問。

			int digest = 0;

			foreach (int value in a)
				digest = HashCode.Combine(digest, value);

			return digest;
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetULongRand() % (ulong)modulo);
	}

	private static int[] GetRandIntList(int size)
	{
		int[] arr = new int[size];

		for (int index = 0; index < size; index++)
			arr[index] = (int)(uint)GetULongRand();

		return arr;
	}

	// ====

	// なんか HashCode 無いっぽいので、ダミーを実装しておく。
	// .NET Core 2.1 (2018) 以降にはあるっぽい。
	public static class HashCode
	{
		public static int Combine(int a, int b)
		{
			ulong x = (ulong)(uint)a;
			ulong y = (ulong)(uint)b;

			x = ((x << 32) | y) % 4294967291;

			return (int)(uint)x;
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		string version = typeof(System.String).Assembly.GetName().Version.ToString();

		//string version = System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription;

		Console.WriteLine(version);
	}
}

----
Adler32 を使って IEqualityComparer<byte[]> を実装する。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test02_a(2);
		Test02_a(3);
		Test02_a(5);
		Test02_a(7);

		Console.WriteLine("OK!");
	}

	private static void Test02_a(int valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<byte[]> hs2 = new HashSet<byte[]>(new Adler32BytesIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			byte[] value = GetRandBytes(GetRandInt(valueScale));
			string strValue = ToString(value);

			bool c1 = hs1.Contains(strValue);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(strValue);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(strValue);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	// バイト列 -> Hex文字列
	private static string ToString(byte[] data)
	{
		return string.Join("", data.Select(v => v.ToString("x2")));
	}

	public class Adler32BytesIEC : IEqualityComparer<byte[]>
	{
		public bool Equals(byte[] a, byte[] b)
		{
			if (a.Length != b.Length)
				return false;

			for (int index = 0; index < a.Length; index++)
				if (a[index] != b[index])
					return false;

			return true;
		}

		public int GetHashCode(byte[] a)
		{
			return (int)Adler32.ComputeHash(a);
		}
	}

	public static class Adler32
	{
		private const uint MODULO = 65521;

		public static uint ComputeHash(IEnumerable<byte> data)
		{
			uint a = 1;
			uint b = 0;

			foreach (byte c in data)
			{
				a = (a + c) % MODULO;
				b = (b + a) % MODULO;
			}
			return a | (b << 16);
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetULongRand() % (ulong)modulo);
	}

	private static byte[] GetRandBytes(int size)
	{
		byte[] data = new byte[size];
		Csprng.GetBytes(data);
		return data;
	}

	// ====
}

----
Adler32 を使って IEqualityComparer<string> を実装する。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Test01_a(10);
		Test01_a(100);
		Test01_a(1000);
		Test01_a(10000);
		Test01_a(100000);
		Test01_a(1000000);
		Test01_a(10000000);

		Console.WriteLine("OK!");
	}

	private static void Test01_a(ulong valueScale)
	{
		HashSet<string> hs1 = new HashSet<string>();
		HashSet<string> hs2 = new HashSet<string>(new Adler32StringIEC());

		for (int testcnt = 0; testcnt < 10000; testcnt++)
		{
			string value = (GetULongRand() % valueScale).ToString();

			bool c1 = hs1.Contains(value);
			bool c2 = hs2.Contains(value);

			if (c1 != c2)
				throw null; // BUG !!!

			if (c1)
			{
				hs1.Remove(value);
				hs2.Remove(value);
			}
			else
			{
				hs1.Add(value);
				hs2.Add(value);
			}
		}
		//Console.WriteLine("OK");
	}

	public class Adler32StringIEC : IEqualityComparer<string>
	{
		public bool Equals(string a, string b)
		{
			return a == b;
		}

		public int GetHashCode(string a)
		{
			return (int)Adler32.ComputeHash(Encoding.UTF8.GetBytes(a));
		}
	}

	public static class Adler32
	{
		private const uint MODULO = 65521;

		public static uint ComputeHash(IEnumerable<byte> data)
		{
			uint a = 1;
			uint b = 0;

			foreach (byte c in data)
			{
				a = (a + c) % MODULO;
				b = (b + a) % MODULO;
			}
			return a | (b << 16);
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	// ====
}

----
組合せ Combination

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		//Test01(5, 3);
		Test01(10, 4);
	}

	private static void Test01(int n, int r)
	{
		Console.WriteLine($"{n} 個 (0 .. {n - 1}) の中から {r} 個選ぶ {Combination(n, r).Count()} 通りの組合せは以下のとおり。");

		foreach (int[] indexes in Combination(n, r))
			Console.WriteLine($"({string.Join(", ", indexes)})");
	}

	// ----

	public static IEnumerable<int[]> Combination(int n, int r)
	{
		if (r < 1 || n < r)
			throw new Exception(); // Bad params

		int[] indexes = Enumerable.Range(0, r).ToArray();

		for (; ; )
		{
			yield return indexes;

			for (int d = 0; ; d++)
			{
				indexes[d]++;

				if (d + 1 < r)
				{
					if (indexes[d] < indexes[d + 1])
						break;
				}
				else
				{
					if (indexes[d] < n)
						break;

					yield break;
				}

				if (1 <= d)
					indexes[d] = indexes[d - 1] + 1;
				else
					indexes[d] = 0;
			}
		}
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			ulong a = GetULongRand();
			ulong b = GetULongRand();
			ulong m = GetULongRandNonZero();
			ulong c = ModPow64(a, b, m);

			Console.WriteLine("ModPow ( " + a + " , " + b + " , " + m + " ) == " + c);
		}
	}

	private static ulong ModPow64(ulong b, ulong e, ulong m)
	{
		ulong a = 1;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModMul64(a, b, m);

			b = ModMul64(b, b, m);
		}
		return a % m;
	}

	private static ulong ModMul64(ulong b, ulong e, ulong m)
	{
		ulong a = 0;

		for (; 1 <= e; e >>= 1)
		{
			if ((e & 1) != 0)
				a = ModAdd64(a, b, m);

			b = ModAdd64(b, b, m);
		}
		return a;
	}

	private static ulong ModAdd64(ulong a, ulong b, ulong m)
	{
		ulong r = (ulong.MaxValue % m + 1) % m;

		while (ulong.MaxValue - a < b)
		{
			unchecked { a += b; }
			b = r;
		}
		return (a + b) % m;
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static ulong GetULongRandNonZero()
	{
		ulong value;

		do
		{
			value = GetULongRand();
		}
		while (value == 0);

		return value;
	}

	// ====
}

----
西暦日付から曜日を取得する。

#include <stdio.h>

int DateToDay(int y, int m, int d)
{
	int day;

	if (m <= 2)
	{
		y--;
	}
	day = y / 400;
	day *= 365 * 400 + 97;
	y %= 400;
	day += y * 365;
	day += y / 4;
	day -= y / 100;

	if (2 < m)
	{
		day -= 31 * 10 - 4;
		m -= 3;
		day += (m / 5) * (31 * 5 - 2);
		m %= 5;
		day += (m / 2) * (31 * 2 - 1);
		m %= 2;
		day += m * 31;
	}
	else
	{
		day += (m - 1) * 31;
	}
	day += d - 1;

	return day;
}

char *DateToWeekday(int y, int m, int d)
{
	static char *weekdays[] =
	{
		"月", "火", "水", "木", "金", "土", "日"
	};

	return weekdays[DateToDay(y, m, d) % 7];
}

// ----

static void Test01(int y, int m, int d)
{
	printf("西暦%04d年%02d月%02d日は%s曜日です。\n", y, m, d, DateToWeekday(y, m, d));
}

int main(void)
{
	Test01(1970,  1,  1);
	Test01(1999, 12, 31);
	Test01(2000,  1,  1);
	Test01(2000, 12, 31);
	Test01(2001,  1,  1);
	Test01(2013,  4, 15);
	Test01(2022, 10, 18);
	Test01(2222,  2,  2);
}

----
西暦日付を和暦に変換する。

#include <stdio.h>
#include <stdlib.h> // for rand()
#include <time.h> // for srand SEED

typedef struct EraInfo_st
{
	int FirstYMD;
	char *Name;
}
EraInfo_t;

extern EraInfo_t EraInfos[];
extern size_t EraInfosLen;

void DateToJapaneseDate(int y, int m, int d, char **pName, char **pNen)
{
	int l = 0;
	int r = EraInfosLen;
	EraInfo_t *i;

	while (l + 1 < r)
	{
		int mid = (l + r) / 2;

		if (EraInfos[mid].FirstYMD <= y * 10000 + m * 100 + d)
			l = mid;
		else
			r = mid;
	}

	i = EraInfos + l;

	if (i->Name)
	{
		*pName = i->Name;
		y -= i->FirstYMD / 10000 - 1;
	}
	else
	{
		*pName = "西暦";
	}

	if (2 <= y)
	{
		static char nenBuff[11];

		*pNen = nenBuff;
		sprintf(nenBuff, "%d", y);
	}
	else
	{
		*pNen = "元";
	}
}

// ----

static void Test01(int y, int m, int d)
{
	char *name;
	char *nen;

	DateToJapaneseDate(y, m, d, &name, &nen);

	printf("西暦%04d年%02d月%02d日は%s%s年%02d月%02d日です。\n", y, m, d, name, nen, m, d);
}

static void Test02(void)
{
	int c;

	srand(time(NULL));

	for (c = 0; c < 1000; c++)
	{
		int y = rand() % 3000 + 1;
		int m = rand() % 12 + 1;
		int d = rand() % 28 + 1;

		Test01(y, m, d);
	}
}

int main(void)
{
	Test01(1865,  5,  1);
	Test01(1867, 12, 31);
	Test01(1868,  1,  1);
	Test01(1912,  7, 29);
	Test01(1912,  7, 30);
	Test01(1926, 12, 24);
	Test01(1926, 12, 25);
	Test01(1989,  1,  7);
	Test01(1989,  1,  8);
	Test01(2019,  4, 30);
	Test01(2019,  5,  1);
	Test01(2022, 10, 18);

	Test02();
}

// ----

EraInfo_t EraInfos[] =
{
	{        0, NULL   },
	{  6450717, "大化" },
	{  6500322, "白雉" },
	{  6541124, NULL   },
	{  6860814, "朱鳥" },
	{  6861001, NULL   },
	{  7010503, "大宝" },
	{  7040616, "慶雲" },
	{  7080207, "和銅" },
	{  7151003, "霊亀" },
	{  7171224, "養老" },
	{  7240303, "神亀" },
	{  7290902, "天平" },
	{  7490504, "天平感宝" },
	{  7490819, "天平勝宝" },
	{  7570906, "天平宝字" },
	{  7650201, "天平神護" },
	{  7670913, "神護景雲" },
	{  7701023, "宝亀" },
	{  7810130, "天応" },
	{  7820930, "延暦" },
	{  8060608, "大同" },
	{  8101020, "弘仁" },
	{  8240208, "天長" },
	{  8340214, "承和" },
	{  8480716, "嘉祥" },
	{  8510601, "仁寿" },
	{  8541223, "斉衡" },
	{  8570320, "天安" },
	{  8590520, "貞観" },
	{  8770601, "元慶" },
	{  8850311, "仁和" },
	{  8890530, "寛平" },
	{  8980520, "昌泰" },
	{  9010831, "延喜" },
	{  9230529, "延長" },
	{  9310516, "承平" },
	{  9380622, "天慶" },
	{  9470515, "天暦" },
	{  9571121, "天徳" },
	{  9610305, "応和" },
	{  9640819, "康保" },
	{  9680908, "安和" },
	{  9700503, "天禄" },
	{  9740116, "天延" },
	{  9760811, "貞元" },
	{  9781231, "天元" },
	{  9830529, "永観" },
	{  9850519, "寛和" },
	{  9870505, "永延" },
	{  9890910, "永祚" },
	{  9901126, "正暦" },
	{  9950325, "長徳" },
	{  9990201, "長保" },
	{ 10040808, "寛弘" },
	{ 10130208, "長和" },
	{ 10170521, "寛仁" },
	{ 10210317, "治安" },
	{ 10240819, "万寿" },
	{ 10280818, "長元" },
	{ 10370509, "長暦" },
	{ 10401216, "長久" },
	{ 10441216, "寛徳" },
	{ 10460522, "永承" },
	{ 10530202, "天喜" },
	{ 10580919, "康平" },
	{ 10650904, "治暦" },
	{ 10690506, "延久" },
	{ 10740916, "承保" },
	{ 10771205, "承暦" },
	{ 10810322, "永保" },
	{ 10840315, "応徳" },
	{ 10870511, "寛治" },
	{ 10950123, "嘉保" },
	{ 10970103, "永長" },
	{ 10971227, "承徳" },
	{ 10990915, "康和" },
	{ 11040308, "長治" },
	{ 11060513, "嘉承" },
	{ 11080909, "天仁" },
	{ 11100731, "天永" },
	{ 11130825, "永久" },
	{ 11180425, "元永" },
	{ 11200509, "保安" },
	{ 11240518, "天治" },
	{ 11260215, "大治" },
	{ 11310228, "天承" },
	{ 11320921, "長承" },
	{ 11350610, "保延" },
	{ 11410813, "永治" },
	{ 11420525, "康治" },
	{ 11440328, "天養" },
	{ 11450812, "久安" },
	{ 11510214, "仁平" },
	{ 11541204, "久寿" },
	{ 11560518, "保元" },
	{ 11590509, "平治" },
	{ 11600218, "永暦" },
	{ 11610924, "応保" },
	{ 11630504, "長寛" },
	{ 11650714, "永万" },
	{ 11660923, "仁安" },
	{ 11690506, "嘉応" },
	{ 11710527, "承安" },
	{ 11750816, "安元" },
	{ 11770829, "治承" },
	{ 11810825, "養和" },
	{ 11820629, "寿永" },
	{ 11840527, "元暦" },
	{ 11850909, "文治" },
	{ 11900516, "建久" },
	{ 11990523, "正治" },
	{ 12010319, "建仁" },
	{ 12040323, "元久" },
	{ 12060605, "建永" },
	{ 12071116, "承元" },
	{ 12110423, "建暦" },
	{ 12140118, "建保" },
	{ 12190527, "承久" },
	{ 12220525, "貞応" },
	{ 12241231, "元仁" },
	{ 12250528, "嘉禄" },
	{ 12280118, "安貞" },
	{ 12290331, "寛喜" },
	{ 12320423, "貞永" },
	{ 12330525, "天福" },
	{ 12341127, "文暦" },
	{ 12351101, "嘉禎" },
	{ 12381230, "暦仁" },
	{ 12390313, "延応" },
	{ 12400805, "仁治" },
	{ 12430318, "寛元" },
	{ 12470405, "宝治" },
	{ 12490502, "建長" },
	{ 12561024, "康元" },
	{ 12570331, "正嘉" },
	{ 12590420, "正元" },
	{ 12600524, "文応" },
	{ 12610322, "弘長" },
	{ 12640327, "文永" },
	{ 12750522, "建治" },
	{ 12780323, "弘安" },
	{ 12880529, "正応" },
	{ 12930906, "永仁" },
	{ 12990525, "正安" },
	{ 13021210, "乾元" },
	{ 13030916, "嘉元" },
	{ 13070118, "徳治" },
	{ 13081122, "延慶" },
	{ 13110517, "応長" },
	{ 13120427, "正和" },
	{ 13170316, "文保" },
	{ 13190518, "元応" },
	{ 13210322, "元亨" },
	{ 13241225, "正中" },
	{ 13260528, "嘉暦" },
	{ 13290922, "元徳" },
	{ 13310911, "元弘" },
	{ 13320523, "正慶" },
	{ 13340305, "建武" },
	{ 13360411, "延元" },
	{ 13400525, "興国" },
	{ 13470120, "正平" },
	{ 13700816, "建徳" },
	{ 13720500, "文中" },
	{ 13750626, "天授" },
	{ 13810306, "弘和" },
	{ 13840518, "元中" },
	{ 13381011, "暦応" },
	{ 13420601, "康永" },
	{ 13451115, "貞和" },
	{ 13500404, "観応" },
	{ 13521104, "文和" },
	{ 13560429, "延文" },
	{ 13610504, "康安" },
	{ 13621011, "貞治" },
	{ 13680307, "応安" },
	{ 13750329, "永和" },
	{ 13790409, "康暦" },
	{ 13810320, "永徳" },
	{ 13840319, "至徳" },
	{ 13871005, "嘉慶" },
	{ 13890307, "康応" },
	{ 13900412, "明徳" },
	{ 13940802, "応永" },
	{ 14280610, "正長" },
	{ 14291003, "永享" },
	{ 14410310, "嘉吉" },
	{ 14440223, "文安" },
	{ 14490816, "宝徳" },
	{ 14520810, "享徳" },
	{ 14550906, "康正" },
	{ 14571016, "長禄" },
	{ 14610201, "寛正" },
	{ 14660314, "文正" },
	{ 14670409, "応仁" },
	{ 14690608, "文明" },
	{ 14870809, "長享" },
	{ 14890916, "延徳" },
	{ 14920812, "明応" },
	{ 15010318, "文亀" },
	{ 15040316, "永正" },
	{ 15210923, "大永" },
	{ 15280903, "享禄" },
	{ 15320829, "天文" },
	{ 15551107, "弘治" },
	{ 15580318, "永禄" },
	{ 15700527, "元亀" },
	{ 15730825, "天正" },
	{ 15930110, "文禄" },
	{ 15961216, "慶長" },
	{ 16150905, "元和" },
	{ 16240417, "寛永" },
	{ 16450113, "正保" },
	{ 16480407, "慶安" },
	{ 16521020, "承応" },
	{ 16550518, "明暦" },
	{ 16580821, "万治" },
	{ 16610523, "寛文" },
	{ 16731030, "延宝" },
	{ 16811109, "天和" },
	{ 16840405, "貞享" },
	{ 16881023, "元禄" },
	{ 17040416, "宝永" },
	{ 17110611, "正徳" },
	{ 17160809, "享保" },
	{ 17360607, "元文" },
	{ 17410412, "寛保" },
	{ 17440403, "延享" },
	{ 17480805, "寛延" },
	{ 17511214, "宝暦" },
	{ 17640630, "明和" },
	{ 17721210, "安永" },
	{ 17810425, "天明" },
	{ 17890219, "寛政" },
	{ 18010319, "享和" },
	{ 18040322, "文化" },
	{ 18180526, "文政" },
	{ 18310123, "天保" },
	{ 18450109, "弘化" },
	{ 18480401, "嘉永" },
	{ 18550115, "安政" },
	{ 18600408, "万延" },
	{ 18610329, "文久" },
	{ 18640327, "元治" },
	{ 18650501, "慶応" },
	{ 18680101, "明治" },
	{ 19120730, "大正" },
	{ 19261225, "昭和" },
	{ 19890108, "平成" },
	{ 20190501, "令和" },
};

size_t EraInfosLen = sizeof(EraInfos) / sizeof(EraInfo_t);

----
西暦1/1/1からの日数を西暦日付に変換する。

#include <stdio.h>

void DayToDate(int day, int *py, int *pm, int *pd)
{
	int y = day;
	int m = 1;
	int d;
	int w;

	y /= 146097;
	y *= 400;
	y += 1;
	day %= 146097;
	w = (day + 306) / 36524;
	day += w < 3 ? w : 3;
	y += (day / 1461) * 4;
	day %= 1461;
	w = (day + 306) / 365;
	day += w < 3 ? w : 3;
	y += day / 366;
	day %= 366;

	if (60 <= day)
	{
		m += 2;
		day -= 60;
		m += (day / 153) * 5;
		day %= 153;
		m += (day / 61) * 2;
		day %= 61;
	}
	m += day / 31;
	day %= 31;
	d = day + 1;

	*py = y;
	*pm = m;
	*pd = d;
}

// ----

#define IsUrudoshi(y) \
	(y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))

static void Error(void)
{
	printf("Error\n");
	exit(1);
}

static int GetDayOfMonth(int y, int m)
{
	switch (m)
	{
	case  1: return 31;
	case  2: return IsUrudoshi(y) ? 29 : 28;
	case  3: return 31;
	case  4: return 30;
	case  5: return 31;
	case  6: return 30;
	case  7: return 31;
	case  8: return 31;
	case  9: return 30;
	case 10: return 31;
	case 11: return 30;
	case 12: return 31;

	default:
		Error();
	}
}

static void Test02(void)
{
	int y = 1;
	int m = 1;
	int d = 1;
	int day = 0;

	while (y < 10000)
	{
		int ry;
		int rm;
		int rd;

		DayToDate(day, &ry, &rm, &rd);

		//if (day % 10000 == 0) printf("%d/%d/%d (%d) -> %d/%d/%d\n", y, m, d, day, ry, rm, rd);

		if (ry != y)
			Error();

		if (rm != m)
			Error();

		if (rd != d)
			Error();

		#define DAY_STEP 13

		d   += DAY_STEP;
		day += DAY_STEP;

		#undef DAY_STEP

		{
			int dom = GetDayOfMonth(y, m);

			if (dom < d)
			{
				d -= dom;
				m++;

				if (12 < m)
				{
					m = 1;
					y++;
				}
			}
		}
	}
}

static void Test01(int day)
{
	int y;
	int m;
	int d;

	DayToDate(day, &y, &m, &d);

	printf("(グレゴリオ暦換算で)西暦1年1月1日から数えて%d日後は西暦%04d年%02d月%02d日です。\n", day, y, m, d);
}

int main(void)
{
	//Test02();

	Test01(0);
	Test01(1000);
	Test01(10000);
	Test01(100000);
	Test01(1000000);
	Test01(1500000);
	Test01(2000000);
	Test01(2500000);
}

----
西暦日付を西暦1/1/1からの日数に変換する。

#include <stdio.h>

int DateToDay(int y, int m, int d)
{
	int day;

	if (m <= 2)
	{
		y--;
	}
	day = y / 400;
	day *= 365 * 400 + 97;
	y %= 400;
	day += y * 365;
	day += y / 4;
	day -= y / 100;

	if (2 < m)
	{
		day -= 31 * 10 - 4;
		m -= 3;
		day += (m / 5) * (31 * 5 - 2);
		m %= 5;
		day += (m / 2) * (31 * 2 - 1);
		m %= 2;
		day += m * 31;
	}
	else
	{
		day += (m - 1) * 31;
	}
	day += d - 1;

	return day;
}

// ----

#define IsUrudoshi(y) \
	(y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))

static void Error(void)
{
	printf("Error\n");
	exit(1);
}

static int GetDayOfMonth(int y, int m)
{
	switch (m)
	{
	case  1: return 31;
	case  2: return IsUrudoshi(y) ? 29 : 28;
	case  3: return 31;
	case  4: return 30;
	case  5: return 31;
	case  6: return 30;
	case  7: return 31;
	case  8: return 31;
	case  9: return 30;
	case 10: return 31;
	case 11: return 30;
	case 12: return 31;

	default:
		Error();
	}
}

static void Test02(void)
{
	int y = 1;
	int m = 1;
	int d = 1;
	int day = 0;

	while (y < 10000)
	{
		int ret = DateToDay(y, m, d);

		//if (ret % 10000 == 0) printf("%d/%d/%d (%d) -> %d\n", y, m, d, day, ret);

		if (ret != day)
			Error();

		#define DAY_STEP 13

		d   += DAY_STEP;
		day += DAY_STEP;

		#undef DAY_STEP

		{
			int dom = GetDayOfMonth(y, m);

			if (dom < d)
			{
				d -= dom;
				m++;

				if (12 < m)
				{
					m = 1;
					y++;
				}
			}
		}
	}
}

static void Test01(int y, int m, int d)
{
	printf("西暦%04d年%02d月%02d日は(グレゴリオ暦換算で)西暦1年1月1日から数えて%d日後です。\n", y, m, d, DateToDay(y, m, d));
}

int main(void)
{
	//Test02();

	Test01(   1,  1,  1);
	Test01(  10,  1,  1);
	Test01( 100,  1,  1);
	Test01(1000,  1,  1);
	Test01(1970,  1,  1);
	Test01(1999, 12, 31);
	Test01(2013,  4, 15);
	Test01(2022, 10, 18);
}

----

#include <stdio.h>

int main(void)
{
	printf("Hello, Happy World!\n");
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		Comparison<int> comp = (a, b) => a - b;

		for (int testcnt = 0; testcnt < 3000; testcnt++)
		{
			int[] arr = GetRandIntList().ToArray();
			int target = GetRandInt(100);

			Array.Sort(arr, comp);

			int[] range1 = GetOuterRange_v1(arr, target, comp);
			int[] range2 = GetOuterRange_v2(arr, target, comp);

			//Console.WriteLine(string.Join(", ", range1[0], range1[1], range1[1] - range1[0]));

			if (
			    range1.Length != 2 ||
			    range2.Length != 2 ||
			    range1[0] != range2[0] ||
			    range1[1] != range2[1]
			    )
			    throw null;
		}
		Console.WriteLine("OK!");
	}

	// ソート済みのリスト内で基準値にマッチする範囲を返す。
	// list: リスト
	// target: 基準値
	// comp: 比較メソッド
	// ret: { 基準値未満の最後の位置, 基準値を超える最初の位置 }
	private static int[] GetOuterRange_v1<T>(IList<T> list, T target, Comparison<T> comp)
	{
		int l = -1;
		int r = list.Count;

		while (l + 1 < r)
		{
			int m = (l + r) / 2;
			int ret = comp(list[m], target);

			if (ret < 0)
			{
				l = m;
			}
			else if (ret > 0)
			{
				r = m;
			}
			else
			{
				l = GetBorder(list, v => comp(v, target) != 0, l, m);
				r = GetBorder(list, v => comp(v, target) == 0, m, r) + 1;
				break;
			}
		}
		return new int[] { l, r };
	}

	private static int GetBorder<T>(IList<T> list, Predicate<T> matchForLeft, int l, int r)
	{
		while (l + 1 < r)
		{
			int m = (l + r) / 2;

			if (matchForLeft(list[m]))
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}
		return l;
	}

	// テスト用
	private static int[] GetOuterRange_v2<T>(IList<T> list, T target, Comparison<T> comp)
	{
		int l;
		int r;

		for (l = list.Count - 1; 0 <= l; l--)
			if (comp(list[l], target) < 0)
				break;

		for (r = 0; r < list.Count; r++)
			if (comp(list[r], target) > 0)
				break;

		return new int[] { l, r };
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList()
	{
		int count = GetRandInt(200);
		int limit = GetRandInt(200) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	// Question:
	// https://twitter.com/potetoichiro/status/1576887286691639296

	public static void Main()
	{
		double RATE_DEGREE_RAD = Math.PI / 180.0;
		int angle = 0;

		D2Point pA = new D2Point(0.0, 0.0);
		D2Point pB = new D2Point(1.0, 0.0);
		D2Point pC = pB + AngleToPoint((angle += 180 - 140) * RATE_DEGREE_RAD, 1.0);
		D2Point pD = pC + AngleToPoint((angle += 180 - 110) * RATE_DEGREE_RAD, 1.0);
		D2Point pE = pD + AngleToPoint((angle +  180 - 130) * RATE_DEGREE_RAD, 1.0);
		D2Point pF = pA + AngleToPoint(100 * RATE_DEGREE_RAD, 1.0);

		double ed = GetAngle(pD - pE);
		double ef = GetAngle(pF - pE);

		double x = ed - ef;

		x /= RATE_DEGREE_RAD;

		Console.WriteLine($"x is {x} degrees.");
	}

	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}
	}

	public static D2Point AngleToPoint(double angle, double distance)
	{
		return new D2Point(
			distance * Math.Cos(angle),
			distance * Math.Sin(angle)
			);
	}

	public static double GetAngle(D2Point pt)
	{
		return GetAngle(pt.X, pt.Y);
	}

	public static double GetAngle(double x, double y)
	{
		if (y < 0.0) return Math.PI * 2.0 - GetAngle(x, -y);
		if (x < 0.0) return Math.PI - GetAngle(-x, y);

		if (x < y) return Math.PI / 2.0 - GetAngle(y, x);

		if (y == 0.0) return 0.0;
		if (y == x) return Math.PI / 4.0;

		double r1 = 0.0;
		double r2 = Math.PI / 4.0;
		double t = y / x;
		double rm;

		for (int c = 1; ; c++)
		{
			rm = (r1 + r2) / 2.0;

			if (50 < c)
				break;

			double rmt = Math.Tan(rm);

			if (t < rmt)
				r2 = rm;
			else
				r1 = rm;
		}
		return rm;
	}
}

----

public class Hello
{
	public static void Main()
	{ }
}

----
例の除雪車問題を二分探索で解く。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	private const int MILLIS_PER_HOUR = 3600000;
	private const double SNOW_INIT = 1.0;
	private const double SNOWPLOW_POWER = 1.0;

	public static void Main()
	{
		double l = 0.0;
		double r = SNOW_INIT;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2;
			double rate = GetDistanceRate(m);

			if (1.5 < rate)
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}

		{
			double m = (l + r) / 2;
			double millis = SNOW_INIT / m;

			TimeSpan t = new TimeSpan(12, 0, 0);
			t -= TimeSpan.FromMilliseconds(millis);

			Console.WriteLine(t.ToString("hh\\:mm\\:ss\\.fff"));
		}
	}

	private static double GetDistanceRate(double snowPerMillis)
	{
		double snow = SNOW_INIT;
		double d = 0.0;

		for (int t = 0; t < MILLIS_PER_HOUR; t++)
		{
			d += SNOWPLOW_POWER / snow;
			snow += snowPerMillis;
		}
		double d1 = d;

		for (int t = 0; t < MILLIS_PER_HOUR; t++)
		{
			d += SNOWPLOW_POWER / snow;
			snow += snowPerMillis;
		}
		double d2 = d;

		return d2 / d1;
	}
}

----
ラングレーの問題 (整角四角形) を解く。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	// ラングレーの問題 (整角四角形) Wiki:
	// https://ja.wikipedia.org/wiki/%E3%83%A9%E3%83%B3%E3%82%B0%E3%83%AC%E3%83%BC%E3%81%AE%E5%95%8F%E9%A1%8C#%E6%95%B4%E8%A7%92%E5%9B%9B%E8%A7%92%E5%BD%A2

	public static void Main()
	{
		LangleyTetragonTest(20, 60, 50, 30);
		LangleyTetragonTest(20, 60, 40, 40);
	}

	private static void LangleyTetragonTest(double a, double b, double c, double d)
	{
		Console.WriteLine($"(a, b, c, d) == ({a:F9}, {b:F9}, {c:F9}, {d:F9}) のとき ...");

		// degree -> rad
		a *= Math.PI / 180.0;
		b *= Math.PI / 180.0;
		c *= Math.PI / 180.0;
		d *= Math.PI / 180.0;

		D2Point pB = new D2Point(0.0, 0.0);
		D2Point pC = new D2Point(1.0, 0.0);
		D2Point pA = GetCrossPoint(pB, pB + AngleToPoint((a + b), 1.0), pC, pC + AngleToPoint(Math.PI - c, 1.0));
		D2Point pD = GetCrossPoint(pB, pB + AngleToPoint(b, 1.0), pC, pC + AngleToPoint(Math.PI - (c + d), 1.0));

		double da = GetAngle(pA - pD);
		double db = GetAngle(pB - pD);

		double e = db - da;

		// rad -> degree
		e *= 180.0 / Math.PI;

		Console.WriteLine($"... e == {e:F9} になります。");
	}

	// 平面座標
	public struct D2Point
	{
		public double X;
		public double Y;

		public D2Point(double x, double y)
		{
			this.X = x;
			this.Y = y;
		}

		public static D2Point operator +(D2Point a, D2Point b)
		{
			return new D2Point(a.X + b.X, a.Y + b.Y);
		}

		public static D2Point operator -(D2Point a, D2Point b)
		{
			return new D2Point(a.X - b.X, a.Y - b.Y);
		}
	}

	// p1-p2 を通る直線と q1-q2 を通る直線の交点を返す。
	private static D2Point GetCrossPoint(D2Point p1, D2Point p2, D2Point q1, D2Point q2)
	{
		double pxd = p2.X - p1.X;
		double qxd = q2.X - q1.X;
		double pyd = p2.Y - p1.Y;
		double qyd = q2.Y - q1.Y;

		double pn = p1.Y * p2.X - p1.X * p2.Y;
		double qn = q1.Y * q2.X - q1.X * q2.Y;

		double d = pyd * qxd - pxd * qyd;

		double x = (qn * pxd - pn * qxd) / d;
		double y = (qn * pyd - pn * qyd) / d;

		return new D2Point(x, y);
	}

	public static D2Point AngleToPoint(double angle, double distance)
	{
		return new D2Point(
			distance * Math.Cos(angle),
			distance * Math.Sin(angle)
			);
	}

	public static double GetAngle(D2Point pt)
	{
		return GetAngle(pt.X, pt.Y);
	}

	public static double GetAngle(double x, double y)
	{
		if (y < 0.0) return Math.PI * 2.0 - GetAngle(x, -y);
		if (x < 0.0) return Math.PI - GetAngle(-x, y);

		if (x < y) return Math.PI / 2.0 - GetAngle(y, x);
		//if (x < 1E-9) return 0.0; // 極端に原点に近い座標の場合、常に 0.0 を返す。

		if (y == 0.0) return 0.0;
		if (y == x) return Math.PI / 4.0;

		double r1 = 0.0;
		double r2 = Math.PI / 4.0;
		double t = y / x;
		double rm;

		for (int c = 1; ; c++)
		{
			rm = (r1 + r2) / 2.0;

			if (50 < c)
				break;

			double rmt = Math.Tan(rm);

			if (t < rmt)
				r2 = rm;
			else
				r1 = rm;
		}
		return rm;
	}
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

public class Hello
{
	public static void Main()
	{
		double l = 0.0;
		double r = 1.0;

		for (int c = 0; c < 50; c++)
		{
			double m = (l + r) / 2;
			double rate = GetDistanceRate(m);

			if (1.5 < rate)
			{
				l = m;
			}
			else
			{
				r = m;
			}
		}

		{
			double m = (l + r) / 2;
			double millis = 1.0 / m;

			TimeSpan t = new TimeSpan(12, 0, 0);
			t -= TimeSpan.FromMilliseconds(millis);

			Console.WriteLine(t.ToString("hh\\:mm\\:ss\\.fff"));
		}
	}

	private static double GetDistanceRate(double snowPerMillis)
	{
		double snow = 1.0;
		double d = 0.0;

		for (int t = 0; t < 3600000; t++)
		{
			d += 1.0 / snow;
			snow += snowPerMillis;
		}
		double d1 = d;

		for (int t = 0; t < 3600000; t++)
		{
			d += 1.0 / snow;
			snow += snowPerMillis;
		}
		double d2 = d;

		return d2 / d1;
	}
}

----

function* Endless(v) {
	for (; ; ) {
		yield v;
	}
}

function* Repeat(v, n) {
	for (var i = 0; i < n; i++) {
		yield v;
	}
}

function* Gaps(n) {
	yield n * (n - 1) - 1;
	yield* Endless(n - 1);
}

function* Sieve(gaps) {
	for (; ; ) {
		yield* Repeat(1, gaps());
		yield 0;
	}
}

function Supplier(e) {
	return () => e.next().value;
}

function Both(a, b) {
	return () => a() & b();
}

function* Primes(max) {
	var s = () => 1;

	for (var n = 2; n <= max; n++) {
		if (s()) {
			s = Both(s, Supplier(Sieve(Supplier(Gaps(n)))));
			yield n;
		}
	}
}

for (var n of Primes(100)) {
	console.log(n);
}

----

#include <stdio.h>
int main(void){
	char p[] = "12345678HelloWorld";
	*(char **)p = p;
	printf("%s\n", ******************************(char *******************************)p + 8);
}

----

#include <stdio.h>

int main()
{
	int n;

	for(n = 1; n <= 100; n++)
	{
		printf("%d\n\0Fizz\n\0______FizzBuzz\n" + (n % 3 + 1 >> 1 ^ 1 ^ ((n % 5 + 3 >> 2 ^ 1) * 5)) * 4, n);
	}
}

----

#include <stdio.h>

main()
{
	void *a[2];
	void ********************************************************************************************************************************
         ********************************************************************************************************************************p;
	void *q;

	p = (void *)a;

	a[0] = p;
	a[1] = p;

	q = *++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--
		*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*--*--*++*++*p++;

	printf("%p\n%p\n%p\n%p\n%p\n", a + 1, a[0], a[1], p, q);
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 100; testcnt++)
		{
			ulong a = GetULongRand();
			ulong b = GetULongRand();
			ulong ans1;
			ulong ans2;

			ans1 = Add64(a, b);
			unchecked { ans2 = a + b; }

			if (ans1 != ans2)
				throw null;

			ans1 = Sub64(a, b);
			unchecked { ans2 = a - b; }

			if (ans1 != ans2)
				throw null;

			ans1 = Mul64(a, b);
			unchecked { ans2 = a * b; }

			if (ans1 != ans2)
				throw null;

			b &= ChooseOne(
				ulong.MaxValue,
				0x0000ffffffffffffUL,
				0x00000000ffffffffUL,
				0x000000000000ffffUL
				);

			if (b == 0)
				b = 1;

			ans1 = Div64(a, b);
			ans2 = a / b;

			if (ans1 != ans2)
				throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static ulong Add64(ulong a, ulong b)
	{
		while (b != 0)
		{
			ulong na = a ^ b;
			b = (a & b) << 1;
			a = na;
		}
		return a;
	}

	private static ulong Sub64(ulong a, ulong b)
	{
		b ^= ulong.MaxValue;
		b = Add64(b, 1);
		return Add64(a, b);
	}

	private static ulong Mul64(ulong a, ulong b)
	{
		ulong c = 0;

		for (; b != 0; b >>= 1, a <<= 1)
			if ((b & 1) != 0)
				c = Add64(c, a);

		return c;
	}

	private static ulong Div64(ulong a, ulong b)
	{
		ulong c = 0;
		ulong d = 1;

		while ((b & (1UL << 63)) == 0)
		{
			b <<= 1;
			d <<= 1;
		}
		while (d != 0)
		{
			if (a >= b)
			{
				a = Sub64(a, b);
				c |= d;
			}
			b >>= 1;
			d >>= 1;
		}
		return c;
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static ulong GetULongRand()
	{
		byte[] data = new byte[8];
		ulong value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static T ChooseOne<T>(params T[] values)
	{
		return values[(int)(GetULongRand() % (ulong)values.Length)];
	}

	// ====
}

----

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;

public class Hello
{
	public static void Main()
	{
		for (int testcnt = 0; testcnt < 30; testcnt++)
		{
			int[] arr1 = GetRandIntList().ToArray();
			int[] arr2 = arr1.ToArray(); // Cloning

			Array.Sort(arr1, (a, b) => a - b);

			CombSort(arr2, (a, b) => a - b);

			for (int index = 0; index < arr1.Length; index++)
				if (arr1[index] != arr2[index])
					throw null;

			//Console.WriteLine("OK");
		}
		Console.WriteLine("OK!");
	}

	private static void CombSort<T>(IList<T> list, Comparison<T> comp)
	{
		for (int h = list.Count; ; ) // comb sort
		{
			h = (int)(h / 1.3);

			//if (h < 2) // 本来はこちら
			if (h < 7) // このあたりが良いらしい。
				break;

			for (int index = h; index < list.Count; index++)
			{
				if (comp(list[index - h], list[index]) > 0) // 逆順か
				{
					// 入れ替え
					T tmp = list[index - h];
					list[index - h] = list[index];
					list[index] = tmp;
				}
			}
		}
		for (int h = 1; h < list.Count; h++) // gnome sort
		{
			for (int index = h; 0 < index; index--)
			{
				if (comp(list[index - 1], list[index]) > 0) // 逆順か
				{
					// 入れ替え
					T tmp = list[index - 1];
					list[index - 1] = list[index];
					list[index] = tmp;
				}
				else // 正順か
				{
					break;
				}
			}
		}
	}

	// ====
	// Random
	// ====

	private static RandomNumberGenerator Csprng = new RNGCryptoServiceProvider();

	private static uint GetRandUInt()
	{
		byte[] data = new byte[4];
		uint value = 0;

		Csprng.GetBytes(data);

		foreach (byte b in data)
		{
			value <<= 8;
			value |= b;
		}
		return value;
	}

	private static int GetRandInt(int modulo)
	{
		return (int)(GetRandUInt() % (uint)modulo);
	}

	private static IEnumerable<int> GetRandIntList()
	{
		int count = GetRandInt(10000);
		int limit = GetRandInt(10000) + 1;

		for (int index = 0; index < count; index++)
			yield return GetRandInt(limit);
	}

	// ====
}

----

main(){}

----

main(){}

----

function* Fibonacci() {
	var a = 1;
	var b = 0;

	for (; ; ) {
		yield a += b;
		yield b += a;
	}
}

var g = Fibonacci();

for (var c = 0; c < 50; c++) {
	console.log(g.next().value);
}

----

console.log(1 + 2);

----

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#define N 3
#define EXP_MAX 1000
#define BLOCKSZ 10
#define VALSZ 10000000000000000000ul

typedef unsigned long uint64;
typedef unsigned __int128 uint128;

typedef struct B_st {
	uint64 Vals[BLOCKSZ];
	struct B_st *Prev;
	struct B_st *Next;
}
B_t;

static B_t Top;
static B_t *Last;

static void MulN(uint64 n) {
	B_t *b = &Top;
	B_t *bn;
	int index;
	uint128 v = 0;

	for(; ; ) {
		for(index = 0; index < BLOCKSZ; index++) {
			v += (uint128)b->Vals[index] * n;
			b->Vals[index] = (uint64)(v % VALSZ);
			v /= VALSZ;
		}
		bn = b->Next;

		if(!bn) {
			if(!v) {
				break;
			}
			bn = (B_t *)calloc(1, sizeof(B_t));

			if(!bn)
				exit(1);

			b->Next = bn;
			bn->Prev = b;
			Last = bn;
		}
		b = bn;
	}
}

static void DoPrint(uint64 n, uint64 exp) {
	B_t *b = Last;
	int index;

	printf("%lu^%lu=", n, exp);

	for(index = BLOCKSZ - 1; !b->Vals[index]; index--);

	printf("%lu", b->Vals[index]);

	while(0 <= --index) {
		printf("%019lu", b->Vals[index]);
	}
	while(b = b->Prev) {
		for(index = BLOCKSZ - 1; 0 <= index; index--) {
			printf("%019lu", b->Vals[index]);
		}
	}
	printf("\n");
}

int main(void) {
	uint64 exp;

	Top.Vals[0] = 1;
	Last = &Top;

	DoPrint(N, 0);

	for(exp = 1; exp <= EXP_MAX; exp++) {
		MulN(N);
		DoPrint(N, exp);
	}
}
